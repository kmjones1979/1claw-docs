## Audit log (agents)

---
title: Audit log (agents)
description: Agents can query audit events with GET /v1/audit/events; same endpoint as humans, scoped to the org.
sidebar_position: 4
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Audit log (agents)

**Endpoint:** `GET /v1/audit/events`  
**Authentication:** Bearer JWT (agent or human)

Returns audit events for the caller's organization. Agents can use this to see their own access history (and other events they are allowed to see). Query parameters may include `resource_id`, `actor_id`, `action`, `from`, `to`, `limit`, `offset` (exact names depend on implementation).

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s "https://api.1claw.xyz/v1/audit/events?limit=20" \
  -H "Authorization: Bearer <token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data } = await client.audit.query({ limit: 20 });
for (const event of data.events) {
  console.log(`${event.action} on ${event.resource_id} by ${event.actor_type}:${event.actor_id}`);
}
```

</TabItem>
</Tabs>

## Example response (200)

```json
{
  "events": [
    {
      "id": "...",
      "org_id": "...",
      "actor_type": "agent",
      "actor_id": "ec7e0226-30f0-4dda-b169-f060a3502603",
      "action": "secret.read",
      "resource_type": "secret",
      "resource_id": "api-keys/openai",
      "metadata": {},
      "timestamp": "2026-02-18T14:00:00Z"
    }
  ],
  "count": 1
}
```

Secret values are never included in audit payloads. See [Audit and compliance](/docs/guides/audit-and-compliance) for more context.


---

## Agent authentication

---
title: Agent authentication
description: Exchange agent_id and api_key for a JWT using POST /v1/auth/agent-token; use the token as Bearer for all subsequent requests.
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Agent authentication

Agents authenticate by exchanging an **agent ID** and **API key** for a short-lived **JWT**. The API key is returned only when the agent is created (or when the key is rotated) and must be stored securely.

## Endpoint

**POST /v1/auth/agent-token**  
**Security:** None (no Bearer required). Request body must contain valid agent credentials.

## Request body

| Field    | Type   | Required | Description                           |
| -------- | ------ | -------- | ------------------------------------- |
| agent_id | string | ✅       | UUID of the agent (from registration) |
| api_key  | string | ✅       | Agent API key (e.g. `ocv_...`)        |

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST https://api.1claw.xyz/v1/auth/agent-token \
  -H "Content-Type: application/json" \
  -d '{
    "agent_id": "ec7e0226-30f0-4dda-b169-f060a3502603",
    "api_key": "ocv_W3_eYj0BSdTjChKwCKRYuZJacmmhVn4ozWIxHV-zlEs"
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
import { createClient } from "@1claw/sdk";

// The SDK exchanges agent credentials for a JWT automatically
// and refreshes the token before it expires
const client = createClient({
  baseUrl: "https://api.1claw.xyz",
  agentId: "ec7e0226-30f0-4dda-b169-f060a3502603",
  apiKey: "ocv_W3_eYj0BSdTjChKwCKRYuZJacmmhVn4ozWIxHV-zlEs",
});
// All subsequent calls use the auto-managed JWT
```

</TabItem>
</Tabs>

## Example response (200)

```json
{
    "access_token": "eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...",
    "token_type": "Bearer",
    "expires_in": 3600
}
```

Use `access_token` in the `Authorization` header for all subsequent API calls. When `expires_in` seconds have passed, call this endpoint again to get a new token.

## JWT scopes

The issued JWT includes a `scopes` claim. If the agent record has scopes set (e.g. from creation or PATCH), those are used. If the agent has no scopes set, the backend derives scopes from the agent's **access policies**: the path patterns from all active policies for that agent become the JWT scopes, so the token reflects current policy-based access. If there are no policies either, scopes default to `["*"]`.

## Error responses

| Code | Meaning                                                       |
| ---- | ------------------------------------------------------------- |
| 401  | Invalid agent_id or api_key, agent inactive, or agent expired |

Never log or expose the API key; treat it like a password.


---

## Agent API errors

---
title: Agent API errors
description: Agent API uses the same error format and status codes as the Human API; 401 often means token expired and the agent should re-authenticate.
sidebar_position: 5
---

# Agent API errors

The Agent API uses the **same** error format and HTTP status codes as the Human API. All errors return RFC 7807 problem-details JSON.

## Common cases for agents

| Code | Meaning | What to do |
|------|---------|------------|
| 401 | Invalid or expired token | Call `POST /v1/auth/agent-token` again and use the new token |
| 403 | No permission for this path | Human must add/update a policy granting the agent read (or write) |
| 403 | Resource limit reached (`type: "resource_limit_exceeded"`) | Organization tier limit hit. Human must upgrade plan at `/settings/billing` |
| 404 | Vault or secret not found | Check vault_id and path |
| 410 | Secret expired, deleted, or over max_access_count | Use a different secret or ask human to create a new version |

See [Human API errors](/docs/human-api/errors) and [Error codes reference](/docs/reference/error-codes) for the full list.


---

## Fetch a secret

---
title: Fetch a secret
description: Retrieve a secret value by vault ID and path with GET /v1/vaults/{vault_id}/secrets/{path}; the agent must have read permission via policy.
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Fetch a secret

Same endpoint as for humans: **GET /v1/vaults/:vault_id/secrets/:path**. The agent sends its JWT; the server checks policies for that agent and returns the decrypted value only if allowed.

## Request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s "https://api.1claw.xyz/v1/vaults/ae370174-9aee-4b02-ba7c-d1519930c709/secrets/api-keys/openai" \
  -H "Authorization: Bearer <agent_access_token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: secret } = await client.secrets.get(
  "ae370174-9aee-4b02-ba7c-d1519930c709",
  "api-keys/openai",
);
// Use secret.value for the intended call — don't log or persist
```

</TabItem>
</Tabs>

## Response (200)

```json
{
  "id": "599dd304-920c-4459-ae07-d62a3515381b",
  "path": "api-keys/openai",
  "type": "api_key",
  "value": "sk-proj-...",
  "version": 1,
  "metadata": {},
  "created_by": "user:...",
  "created_at": "2026-02-18T12:00:00Z"
}
```

Use the `value` only for the intended operation; do not log or cache it longer than necessary.

## Errors

| Code | Meaning |
|------|---------|
| 401 | Invalid or expired token — refresh with POST /v1/auth/agent-token |
| 403 | No read permission for this path |
| 404 | Vault or secret not found |
| 410 | Secret expired, deleted, or over max_access_count |


---

## List accessible secrets

---
title: List accessible secrets
description: List secret metadata in a vault with GET /v1/vaults/{vault_id}/secrets; only paths the agent can read are visible; values are never in list responses.
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# List accessible secrets

**Endpoint:** `GET /v1/vaults/:vault_id/secrets`  
**Authentication:** Bearer JWT (agent)

Returns **metadata** for secrets in the vault. The server applies policy so the agent only sees secrets it has read access to. Optional query: `?prefix=...` to filter by path prefix.

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets?prefix=api-keys" \
  -H "Authorization: Bearer <agent_token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data } = await client.secrets.list(VAULT_ID);
for (const s of data.secrets) {
  console.log(`${s.path} (${s.type}, v${s.version})`);
}
```

</TabItem>
</Tabs>

## Example response (200)

```json
{
  "secrets": [
    {
      "id": "599dd304-920c-4459-ae07-d62a3515381b",
      "path": "api-keys/openai",
      "type": "api_key",
      "version": 1,
      "metadata": {},
      "created_at": "2026-02-18T12:00:00Z"
    }
  ]
}
```

Values are **never** returned in list responses. To get a value, call [GET .../secrets/:path](/docs/agent-api/fetch-secret) for each path you need.


---

## Agent API overview

---
title: Agent API overview
description: Agents use the same REST API as humans; they authenticate with POST /v1/auth/agent-token and then list and fetch secrets they are allowed to access.
sidebar_position: 0
---

# Agent API overview

The **Agent API** is the same REST API as the Human API, with a different **auth entry point**. Agents do not log in with email/password; they use an **agent API key** (`ocv_...`) to get a short-lived JWT, then call the same endpoints to list and fetch secrets.

## Base URL

Same as Human API: `https://api.1claw.xyz` (or your Cloud Run URL).

## Authentication

1. **Obtain agent credentials** — A human registers an agent via `POST /v1/agents` and receives an `api_key` (`ocv_...`). Store it securely in the agent’s config.
2. **Exchange key for JWT** — `POST /v1/auth/agent-token` with `{ "agent_id": "<uuid>", "api_key": "ocv_..." }` → returns `access_token` and `expires_in`.
3. **Use the JWT** — Send `Authorization: Bearer <access_token>` on every request. Refresh the token before it expires by calling the agent-token endpoint again.

## What agents can do

- **List secrets** — `GET /v1/vaults/:vault_id/secrets` — Returns metadata only for paths the agent is allowed to read.
- **Get secret value** — `GET /v1/vaults/:vault_id/secrets/:path` — Returns decrypted value if policy grants read.
- **Create/update secrets** — `PUT .../secrets/:path` — Only if a policy grants write.

Agents typically **do not** create vaults, register other agents, or manage policies; those operations are for humans. Access is determined entirely by policies created by humans.

## Next

- [Agent authentication](/docs/agent-api/authentication) — Request/response for agent-token.
- [Fetch a secret](/docs/agent-api/fetch-secret) — GET secret by path with examples.


---

## HSM architecture

---
title: HSM architecture
description: 1claw uses envelope encryption with DEKs per secret and HSM-backed KEKs; in production Google Cloud KMS holds the keys.
sidebar_position: 1
---

# HSM architecture

1claw encrypts every secret with **envelope encryption**: a random **Data Encryption Key (DEK)** encrypts the secret; the DEK itself is encrypted (wrapped) by a **Key Encryption Key (KEK)** that lives in an HSM and never leaves it.

## Key hierarchy

- **KEK (Key Encryption Key)** — One per vault. Created in the HSM when you create a vault. Used only to wrap/unwrap DEKs. In production this is a symmetric key in **Google Cloud KMS**.
- **DEK (Data Encryption Key)** — Generated per secret (or per operation). Used with AES-256-GCM to encrypt the secret value. The DEK is wrapped with the vault’s KEK and stored alongside the ciphertext; it never exists in plain form outside the HSM boundary during wrap/unwrap.
- **JWT signing key** — A separate Ed25519 key in the same KMS key ring. Used to sign and verify JWTs for human and agent auth. Only the public part is used for verification; signing happens inside KMS.

## Flow (create secret)

1. Client sends plaintext secret to the API with a vault ID and path.
2. API generates a new DEK, encrypts the plaintext with AES-256-GCM using the DEK.
3. API calls KMS to wrap the DEK with the vault’s KEK; the wrapped DEK is stored with the ciphertext, IV, and auth tag.
4. Stored row: `vault_id`, `path`, `ciphertext`, `wrapped_dek`, `iv`, `auth_tag`, metadata, version, etc.

## Flow (read secret)

1. Client requests secret by vault ID and path (with valid JWT and policy allowing read).
2. API loads the latest version’s ciphertext and wrapped DEK.
3. API calls KMS to unwrap the DEK with the vault’s KEK.
4. API decrypts the ciphertext with the DEK and returns the plaintext to the client.

## Production vs local

- **Production** — KEKs and JWT key in **Google Cloud KMS** (same GCP project as Cloud Run). Service account has `cryptoKeyEncrypterDecrypter` and `signerVerifier` on the key ring.
- **Local** — SoftHSM or in-memory provider for development; same envelope design, keys not persisted to real HSM.

## Why this matters

Secrets at rest are encrypted with keys that never leave the HSM. Compromise of the database or application only exposes ciphertext and wrapped DEKs; without KMS access, secrets cannot be decrypted. Access is always mediated by the API and policies, and can be audited.

See [Key hierarchy](/docs/security/key-hierarchy) and [Security overview](/docs/security/hsm-overview) for more detail.


---

## Human vs Agent API

---
title: Human vs Agent API
description: The same REST API serves humans and agents; auth and typical operations differ by persona — humans manage vaults and grants, agents fetch secrets.
sidebar_position: 3
---

# Human vs Agent API

1claw exposes **one REST API** at a single base URL. Whether you’re a **human** (developer, team) or an **AI agent**, you use the same base URL and the same endpoint paths. What changes is **how you authenticate** and **which operations** you typically perform.

## Human API (secret owner)

**Who:** A person or team that owns the vault and secrets.

**Auth:**

- **Email + password** — `POST /v1/auth/token` with `{ "email": "...", "password": "..." }` → JWT.
- **Google OAuth** — `POST /v1/auth/google` with `{ "id_token": "..." }` → JWT.
- **Personal API key** — `POST /v1/auth/api-key-token` with `{ "api_key": "1ck_..." }` → JWT.

**Typical operations:**

- Create/list/get/delete **vaults**.
- Create/read/update/delete **secrets** (PUT/GET/DELETE by path).
- List secrets (metadata only).
- Create/list/update/delete **policies** (grants) for a vault.
- **Register** agents, list agents, rotate agent keys, deactivate agents.
- Create/revoke **share** links.
- View **audit** events, **billing/usage**, **org members**, and **API keys**.

All of these require a **Bearer JWT** in the `Authorization` header (from one of the auth methods above).

## Agent API (consumer)

**Who:** An AI agent (Claude, GPT, MCP server, custom bot) that has been registered and granted access via policies.

**Auth:**

- **Agent API key** — When you register an agent you receive an API key (`ocv_...`). The agent (or its runtime) calls `POST /v1/auth/agent-token` with `{ "agent_id": "<uuid>", "api_key": "ocv_..." }` and receives a short-lived JWT.

**Typical operations:**

- **List** secrets in a vault (metadata only) — `GET /v1/vaults/:vault_id/secrets`.
- **Get** a secret’s value by path — `GET /v1/vaults/:vault_id/secrets/:path`.
- Optionally **create/update** secrets if the policy grants `write`.

The agent does **not** create vaults, register other agents, or manage policies. It only accesses secrets it’s allowed to by policy. Same endpoints, same JWT format; the `sub` claim is `agent:<uuid>` so the backend applies agent-scoped policies.

## Why separate auth?

Humans need long-lived sessions or API keys for dashboards and automation; agents need short-lived tokens so a leaked token has limited use. Both end up with a JWT; the **subject** (`user:<id>` vs `agent:<id>`) and **org** determine which policies apply. One API, one policy engine, two personas.

## Next

- [Quickstart for humans](/docs/quickstart/humans) — Get a JWT and create a vault and secret.
- [Quickstart for agents](/docs/quickstart/agents) — Get an agent token and fetch a secret.
- [Give an agent access](/docs/guides/give-agent-access) — End-to-end: secret → agent → policy → fetch.


---

## Parts of 1claw

---
title: Parts of 1claw
description: The API, Dashboard, MCP server, CLI, and SDK — what each is for and when to use it.
sidebar_position: 4
---

# Parts of 1claw

1claw is one product with several ways to use it. Pick the right one for your role and environment.

## Vault API

**What it is:** The REST API that everything else talks to. Base URL: `https://api.1claw.xyz`. Handles auth, vaults, secrets, policies, agents, sharing, billing, and audit.

**When to use it:** When you're integrating 1claw into your own app, script, or service. You send HTTP requests with a Bearer token (JWT or API key). Use the [API reference](/docs/reference/api-reference) and the [OpenAPI spec](https://github.com/1clawAI/1claw-openapi-spec) for full details.

**You need:** A user JWT (from login or device flow) or a personal API key (`1ck_`), or an agent JWT (from `POST /v1/auth/agent-token` with an agent API key `ocv_`).

---

## Dashboard

**What it is:** The web UI at [1claw.xyz](https://1claw.xyz). Sign in with email/password or Google, then manage vaults, secrets, agents, policies, sharing, audit log, API keys, billing, and team.

**When to use it:** For day-to-day setup and management — creating vaults, storing secrets, registering agents, granting access, viewing audit logs, upgrading or managing billing. Most humans use the dashboard as the main way to interact with 1claw.

**You need:** An account (sign up at 1claw.xyz). Optional: MFA and API keys for extra security.

---

## MCP Server

**What it is:** A [Model Context Protocol](https://modelcontextprotocol.io) server that exposes 1claw as tools (e.g. `list_secrets`, `get_secret`, `put_secret`, `create_vault`, `share_secret`, `simulate_transaction`, `submit_transaction`). AI assistants (Claude, Cursor, GPT, etc.) call these tools so they can use secrets at runtime without you pasting credentials.

**When to use it:** When you want an AI agent to read or write secrets, create vaults, or sign transactions through 1claw. Configure your AI tool to use the 1claw MCP server (hosted at `mcp.1claw.xyz` or run locally). The agent uses its own API key; you control what it can do via policies.

**You need:** An agent registered in the dashboard (or via API), with policies that grant the agent access to the vaults and paths it needs. See [MCP Setup](/docs/mcp/setup) and [Give an agent access](/docs/guides/give-agent-access).

---

## CLI

**What it is:** A command-line tool (`@1claw/cli`) for CI/CD, servers, and local scripts. Log in via browser (device flow) or with email/password, then run commands for vaults, secrets, agents, policies, and shares. Can inject secrets into env or run a command with secrets loaded.

**When to use it:** For scripts, cron jobs, deploy pipelines, or any environment where you want to pull secrets or run a process with secrets without building API calls yourself. Use `1claw env run -- your-command` to run a command with vault secrets as environment variables.

**You need:** Node.js 20+; install with `npm i -g @1claw/cli`. Then `1claw login` (device flow) or set `ONECLAW_TOKEN` / `ONECLAW_API_KEY`. See [CLI guide](/docs/guides/cli).

---

## SDK

**What it is:** TypeScript/JavaScript client (`@1claw/sdk`) that wraps the REST API. Methods for auth, vaults, secrets, policies, agents, sharing, billing, audit, chains, and (for agents) transaction simulation and submission.

**When to use it:** When you're writing an app or service in Node/TS and want typed, high-level calls instead of raw `fetch`. Same auth as the API (user or agent token, or API key). Supports x402 payment flow if you need to pay per request.

**You need:** `npm i @1claw/sdk` or `pnpm add @1claw/sdk`. Configure with `baseUrl` and either a token or credentials to obtain one. See [JavaScript / TypeScript SDK](/docs/sdks/javascript).

---

## How they fit together

| You are…                    | Best starting point        |
| --------------------------- | -------------------------- |
| A human setting things up   | **Dashboard**              |
| A human in a script/CI      | **CLI** or **SDK**         |
| An AI agent (MCP client)    | **MCP Server** (hosted or local) |
| A custom app or backend     | **SDK** or **Vault API**   |

All of them talk to the same Vault API and the same data. Create a vault in the dashboard, store a secret via the API or CLI, and an agent using MCP can read it — as long as you’ve granted that agent access with a policy.

For definitions of terms (vault, secret, policy, agent, etc.), see the [Glossary](/docs/reference/glossary). For common errors and fixes, see [Troubleshooting](/docs/guides/troubleshooting).


---

## Secrets model

---
title: Secrets model
description: Secrets live in vaults at paths, have types and optional metadata, expiry, and versioning; values are encrypted and never returned in list responses.
sidebar_position: 2
---

# Secrets model

A **secret** is a named value stored inside a **vault** at a **path**. The path is a slash-separated identifier (e.g. `passwords/one`, `api-keys/stripe`). Paths must be alphanumeric with hyphens, underscores, and slashes; no leading or trailing slashes.

## Secret types

The API accepts a `type` field when creating or updating a secret. Allowed values (from the vault schema):

- `password`
- `api_key`
- `private_key`
- `certificate`
- `file`
- `note`
- `ssh_key`
- `env_bundle`

The value is always stored as bytes; for display the API may return it as a UTF-8 string when possible.

## Metadata and options

- **metadata** — Optional JSON object (e.g. tags, description). Stored and returned with the secret.
- **expires_at** — Optional ISO 8601 datetime. After this time the secret is treated as expired and will not be returned (410 Gone).
- **max_access_count** — Optional integer. After this many reads, the secret returns 410 Gone.
- **rotation_policy** — Optional; reserved for future rotation behavior.

## Versioning

Each `PUT` to the same vault and path creates a **new version** (version 1, 2, 3, …). Listing secrets returns the latest version per path; you can request a specific version via the versioned endpoint if the API exposes it. Delete is soft-delete (marks all versions of that path as deleted).

## What is returned

- **List secrets** (`GET /v1/vaults/:vault_id/secrets`) — Returns metadata only: id, path, type, version, metadata, created_at, expires_at. Never the value.
- **Get secret** (`GET /v1/vaults/:vault_id/secrets/:path`) — Returns metadata **and** the decrypted value (only if the caller has read permission and the secret is not expired or over access count).

Values are never logged or returned in list/audit responses; only “secret accessed” style events are recorded.


---

## Trust model

---
title: Trust model
description: 1claw trusts the HSM and the API to enforce policy; clients get secrets only after authentication and policy checks; all access is audited.
sidebar_position: 4
---

# Trust model

## What 1claw trusts

- **HSM (e.g. Cloud KMS)** — Keys are generated and used only inside the HSM. The API never has access to raw KEKs or long-term signing keys; it only requests wrap/unwrap/sign operations.
- **Database** — Stores ciphertext, wrapped DEKs, metadata, policies, and audit events. The database is not trusted with plaintext secrets; it only holds encrypted data and policy records.
- **API** — The only component that can decrypt secrets. It authenticates every request (JWT), loads policies for the caller, and returns secret values only when policy allows. All access is logged for audit.

## What the client must do

- **Humans** — Keep credentials (password, API key) secure; use HTTPS; treat the JWT as sensitive (short-lived in the case of agent tokens).
- **Agents** — Store the agent API key securely (e.g. in the agent’s secure config, not in prompts or logs). Use the token endpoint to get a short-lived JWT and use it only over HTTPS.

## Zero-trust style guarantees

- **Secrets at rest** — Encrypted with DEKs wrapped by HSM KEKs; no plaintext in the DB.
- **Secrets in transit** — Served only over HTTPS; client must use TLS.
- **Access control** — Every request is authorized by policy; there is no “open” read. Vault creators can always access their vault; others need an explicit policy.
- **Revocation** — Disable an agent, delete a policy, or rotate a key; subsequent requests fail. No long-lived cache of secrets in the API.
- **Audit** — All access (and failures) can be recorded; see [Audit and compliance](/docs/guides/audit-and-compliance).

See [Zero trust](/docs/security/zero-trust) for a longer treatment.


---

## What is 1claw?

---
title: What is 1claw?
description: 1claw is a cloud HSM-backed secrets manager for humans and AI agents with vaults, path-based secrets, and policy-based access.
sidebar_position: 0
---

# What is 1claw?

1claw is a **cloud-hosted secrets manager** built for both **humans** (developers, teams) and **AI agents** (Claude, GPT, MCP servers, custom bots). Secrets are stored in **vaults** and encrypted with keys held in a **Hardware Security Module (HSM)** — in production, Google Cloud KMS. Access is controlled by **policies** that tie a principal (user or agent) to path patterns and permissions, with optional expiry and conditions.

## Core ideas

- **Vaults** — A vault is a named container (e.g. "Production", "CI"). Each vault has its own KEK in the HSM. You create vaults, then store secrets inside them at paths like `api-keys/stripe` or `passwords/db`.
- **Secrets** — Stored by path within a vault. Each secret has a type (e.g. `password`, `api_key`), optional metadata, optional expiry, and versioning. The secret value is encrypted with a DEK that is wrapped by the vault’s KEK.
- **Agents** — Registered identities that get an API key (`ocv_...`). They exchange the key for a JWT and then call the same REST API to list and fetch secrets they’re allowed to see.
- **Policies (grants)** — Define who can do what: e.g. agent `X` can `read` secrets under `**` in vault `V`, or user `Y` can `read,write` paths matching `prod/*`. Policies can have conditions (IP, time window) and expiry.

## Why two personas?

Humans need to **create** vaults, **store** and **rotate** secrets, **register** agents, and **grant** or **revoke** access. Agents only need to **authenticate** and **fetch** the secrets they’re allowed to use. Same API, same base URL; the JWT identifies whether the caller is a user or an agent and which org they belong to. Policies are evaluated on every request so access is always up to date and auditable.

## Next

- [Parts of 1claw](/docs/concepts/parts-of-1claw) — API, Dashboard, MCP, CLI, SDK: what each is for and when to use it.
- [HSM architecture](/docs/concepts/hsm-architecture) — How keys and encryption work.
- [Secrets model](/docs/concepts/secrets-model) — Paths, types, versioning.
- [Human vs Agent API](/docs/concepts/human-vs-agent-api) — When to use which and how auth differs.


---

## Audit and compliance

---
title: Audit and compliance
description: 1claw records access and failures in an audit log; query events via GET /v1/audit/events; secret values are never logged.
sidebar_position: 5
---

# Audit and compliance

All API access (and relevant failures) can be recorded in an **audit log**. Secret **values** are never stored in audit events; only metadata (e.g. path, action, actor, timestamp) is recorded.

## Querying audit events

**GET /v1/audit/events** — Returns events for the caller’s organization. Query parameters may include:

- `resource_id` — Filter by resource (e.g. secret path).
- `actor_id` — Filter by actor (user or agent UUID).
- `action` — Filter by action type.
- `from`, `to` — Time range (ISO 8601).
- `limit`, `offset` — Pagination.

### Example request

```bash
curl "https://api.1claw.xyz/v1/audit/events?action=secret.read&limit=25" \
  -H "Authorization: Bearer $TOKEN"
```

### Example response

```json
{
  "events": [
    {
      "id": "a7e2c...",
      "action": "secret.read",
      "actor_id": "agent-uuid",
      "actor_type": "agent",
      "resource_type": "secret",
      "resource_id": "secret-uuid",
      "org_id": "org-uuid",
      "details": { "vault_id": "vault-uuid", "path": "keys/eth-signer" },
      "ip_address": "203.0.113.50",
      "created_at": "2026-02-27T14:00:00Z"
    }
  ],
  "count": 1
}
```

Each event includes `id`, `org_id`, `actor_type`, `actor_id`, `action`, `resource_type`, `resource_id`, `details`, `ip_address`, and `created_at`.

## Typical events

- `secret.read`, `secret.write`, `secret.delete` — Secret access (path and actor; no value).
- `auth.success`, `auth.failure` — Authentication attempts (no credentials logged).
- `policy.create`, `policy.update`, `policy.delete` — Access policy changes.
- `agent.register`, `agent.rotate_key`, `agent.deactivate` — Agent lifecycle events.
- `transaction.submit` — Transaction submitted via crypto proxy.
- `transaction.simulate` — Transaction simulation requested.

## Tamper-evident hash chain

Every audit event includes a cryptographic hash chain that links it to the previous event:

- `prev_event_id` — UUID of the immediately preceding event in the org's audit log.
- `integrity_hash` — SHA-256 of `prev_hash|event_id|actor_id|action|resource_type|resource_id|timestamp`.

This makes the audit log **append-only and tamper-evident**: modifying or deleting any event breaks the hash chain for all subsequent entries. You can verify integrity by walking the chain from the latest event back to the first (`prev_event_id = NULL`).

## Best practices

Use the audit log for compliance reviews, incident response, and access analysis. Export or forward events to your SIEM or logging pipeline as needed.

### SDK AuditSink plugin

The TypeScript SDK supports an `AuditSink` plugin interface for forwarding audit events to external systems (e.g. Splunk, Datadog, or a custom webhook). Register a sink when constructing the client and every event your SDK session produces will be mirrored to your target in real time. See the [SDK overview](/docs/sdks/overview) for details on the plugin architecture.


---

## Billing & Usage

---
title: Billing & Usage
description: Subscription tiers, usage tracking, prepaid credits, x402 micropayments, and how to monitor your consumption.
sidebar_position: 5
---

# Billing & Usage

1claw tracks every API request and offers flexible billing through subscription tiers with optional prepaid credits or on-chain micropayments for overages.

## Subscription Tiers

Every organization starts on the **Free** tier and can upgrade to paid plans for higher limits:

| Tier           | Monthly Price | Annual Price | Requests/mo | Vaults    | Secrets   | Agents    |
| -------------- | ------------- | ------------ | ----------- | --------- | --------- | --------- |
| **Free**       | $0            | —            | 1,000       | 3         | 50        | 2         |
| **Pro**        | $29           | $290         | 25,000      | 25        | 500       | 10        |
| **Business**   | $149          | $1,490       | 100,000     | 100       | 5,000     | 50        |
| **Enterprise** | Custom        | Custom       | Unlimited   | Unlimited | Unlimited | Unlimited |

### Resource Limits

Each tier enforces hard limits on the number of vaults, secrets, and agents your organization can create. When you attempt to create a resource beyond your limit, the API returns **403 Forbidden** with `type: "resource_limit_exceeded"`:

```json
{
  "type": "resource_limit_exceeded",
  "title": "Resource Limit Exceeded",
  "status": 403,
  "detail": "Vault limit reached (3/3 on free tier). Upgrade your plan for more."
}
```

Unlike request quotas (which support overages via credits or x402), resource limits require upgrading your subscription tier. The dashboard displays an upgrade prompt automatically when a limit is hit.

### Upgrading

Visit [1claw.xyz/settings/billing](https://1claw.xyz/settings/billing) to:

- Start a subscription checkout (Stripe)
- View your current tier and limits
- Manage your subscription (upgrade, downgrade, cancel)
- Access the Stripe customer portal for invoices and payment methods

## Usage Tracking

Every authenticated API request is recorded as a usage event with:

- **Method and endpoint** — e.g. `GET /v1/vaults/:id/secrets/:path`
- **Principal** — Which user or agent made the request
- **Status code** — Whether the request succeeded
- **Price** — The cost of the operation (see pricing below)
- **Timestamp** — When the request was made

Usage is unified across all access methods. Whether a secret is read from the dashboard, the TypeScript SDK, or an MCP tool call, it counts as one request against the same quota.

## Pricing

### Base Rates

| Endpoint                                         | Price   |
| ------------------------------------------------ | ------- |
| Read a secret (`GET /v1/vaults/*/secrets/*`)     | $0.001  |
| Write a secret (`PUT /v1/vaults/*/secrets/*`)    | $0.005  |
| Create a share link (`POST /v1/secrets/*/share`) | $0.002  |
| Access a shared secret (`GET /v1/share/*`)       | $0.001  |
| Query audit events (`GET /v1/audit/events`)      | $0.0005 |
| Auth, health, listing endpoints                  | Free    |

### Overage Rates (After Tier Limit)

When you exceed your tier's monthly request limit, overage charges apply. **Pro** and **Business** tiers get discounted overage rates:

| Tier       | Overage Rate per Request |
| ---------- | ------------------------ |
| Free       | $0.001 (standard rate)   |
| Pro        | $0.0008 (20% discount)   |
| Business   | $0.0006 (40% discount)   |
| Enterprise | Custom                   |

## Overage Methods

When your monthly tier limit is exhausted, you can choose how to pay for overages:

### 1. Prepaid Credits (Recommended)

Top up your account with credits ($5–$1,000) via Stripe. Credits are deducted automatically when you exceed your tier limit, expire after 12 months, and benefit from your tier's discounted overage rates.

**Benefits:**

- Automatic deduction — no per-request payment flow
- Tier discounts apply (Pro/Business save 20–40%)
- Simple billing — one-time top-up, credits last 12 months
- No blockchain interaction required

**How it works:**

1. Visit `/settings/billing` and click "Top Up Credits"
2. Choose an amount ($5, $10, $25, $50, $100, $250, $500, $1,000)
3. Complete Stripe checkout
4. Credits are added immediately and used automatically for overages

### 2. x402 Micropayments (On-Chain)

Pay per-request on the Base network (EIP-155:8453) using the [x402 protocol](https://www.x402.org/). Each overage request requires an on-chain payment before the API responds.

**Benefits:**

- Pay only for what you use — no prepayment
- On-chain transparency
- Works with any x402-compatible wallet

**How it works:**
When the free tier is exhausted, the API returns `402 Payment Required` with an x402 payment envelope:

```json
{
    "type": "https://httpproblems.com/http-status/402",
    "title": "Payment Required",
    "status": 402,
    "detail": "Tier limit exceeded. Pay per-request or top up credits.",
    "x402": {
        "scheme": "exact",
        "network": "eip155:8453",
        "maxAmountRequired": "0.001",
        "resource": "/v1/vaults/:vault_id/secrets/:path",
        "description": "Read a secret",
        "payTo": "0x...",
        "deadline": 1740000000
    }
}
```

Clients that support x402 can pay the required amount on-chain and retry the request.

### Choosing Your Overage Method

Toggle between credits and x402 in the billing dashboard or via API:

```bash
# Use prepaid credits for overages
curl -X PATCH -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"overage_method": "credits"}' \
  https://api.1claw.xyz/v1/billing/overage-method

# Use x402 micropayments for overages
curl -X PATCH -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"overage_method": "x402"}' \
  https://api.1claw.xyz/v1/billing/overage-method
```

**Default:** New organizations default to `credits`. If you have no credits and haven't set up x402, you'll need to top up credits or configure x402 before overages can be processed.

## Monitoring Usage

### Dashboard

Visit [1claw.xyz/settings/billing](https://1claw.xyz/settings/billing) to see:

- Current subscription tier and limits
- Current month's total requests vs tier limit
- Usage breakdown (free tier vs overages)
- Credit balance and expiring credits (next 30 days)
- Overage method (credits or x402)
- Total cost (subscription + overages)
- Recent usage history
- Credit transaction ledger

### API

#### Get Full Subscription Summary

```bash
curl -H "Authorization: Bearer $TOKEN" \
  https://api.1claw.xyz/v1/billing/subscription
```

Response includes subscription status, usage, and credits:

```json
{
    "subscription": {
        "tier": "pro",
        "status": "active",
        "current_period_end": "2026-03-20T00:00:00Z",
        "cancel_at_period_end": false
    },
    "usage": {
        "tier_limit": 25000,
        "current_month": {
            "total_requests": 18472,
            "tier_requests": 18472,
            "overage_requests": 0,
            "total_cost_usd": 0.0
        }
    },
    "credits": {
        "balance_usd": 50.0,
        "expiring_next_30_days": 0.0
    },
    "overage_method": "credits"
}
```

#### Get Credit Balance

```bash
curl -H "Authorization: Bearer $TOKEN" \
  https://api.1claw.xyz/v1/billing/credits/balance
```

```json
{
    "balance_usd": 50.0,
    "expiring_next_30_days": 0.0,
    "expiring_credits": []
}
```

#### Get Credit Transactions

```bash
curl -H "Authorization: Bearer $TOKEN" \
  "https://api.1claw.xyz/v1/billing/credits/transactions?limit=20&offset=0"
```

```json
{
    "transactions": [
        {
            "id": "uuid",
            "type": "topup",
            "amount_usd": 50.0,
            "balance_after_usd": 50.0,
            "created_at": "2026-02-15T10:30:00Z"
        },
        {
            "id": "uuid",
            "type": "usage",
            "amount_usd": -0.5,
            "balance_after_usd": 49.5,
            "description": "Overage charges for 625 requests",
            "created_at": "2026-02-18T14:22:00Z"
        }
    ],
    "total": 2,
    "limit": 20,
    "offset": 0
}
```

#### Legacy Usage Endpoints (Still Available)

```bash
# Get current month summary
curl -H "Authorization: Bearer $TOKEN" \
  https://api.1claw.xyz/v1/billing/usage

# Get recent usage events
curl -H "Authorization: Bearer $TOKEN" \
  "https://api.1claw.xyz/v1/billing/history?limit=50"
```

## Quota Response Headers

Every authenticated API response includes headers that let you monitor usage programmatically without polling the billing endpoint:

| Header | Description |
| ------ | ----------- |
| `X-RateLimit-Requests-Used` | Requests consumed this billing period |
| `X-RateLimit-Requests-Limit` | Tier request limit for this period |
| `X-RateLimit-Requests-Percent` | Usage percentage (e.g. `74`) |
| `X-Quota-Warning` | Present when usage exceeds 80% of the tier limit |
| `X-Credit-Balance-Cents` | Current credit balance in cents |
| `X-Credit-Expiring-Soon` | Present when credits expire within 30 days |
| `X-Overage-Method` | Active overage method (`credits` or `x402`) |

These headers are useful for building dashboards, alerting on approaching limits, and triggering automatic credit top-ups.

:::tip Programmatic monitoring
Check `X-Quota-Warning` and `X-RateLimit-Requests-Percent` after each API call to trigger alerts before your quota is exhausted.
:::

## Credit Expiry

Prepaid credits expire **12 months** after purchase. The system sends automated email reminders at 30 days and 7 days before expiry. A nightly job at 00:05 UTC processes expired top-ups. Credits are consumed in FIFO order (oldest first), so topping up regularly ensures you always have fresh credits.

## MCP and Billing

MCP tool calls go through the same vault API and count toward the same usage quota. When an agent calls `get_secret` via MCP, that's one API request.

If your tier limit is exhausted and you have no credits (or x402 configured), the MCP server will return a clear error message:

> "Tier limit exceeded. Top up credits or configure payment at https://1claw.xyz/settings/billing"

## Enterprise

For organizations with custom requirements, unlimited usage, dedicated support, or on-premise deployments, contact us at [ops@1claw.xyz](mailto:ops@1claw.xyz) to discuss Enterprise pricing and terms.


---

## 1Claw CLI

---
title: CLI
description: Use the 1Claw CLI for CI/CD, DevOps, and servers. Browser-based login, env pull/push/run, and full API coverage.
sidebar_position: 11
---

# 1Claw CLI

The `@1claw/cli` package provides a full-featured command-line interface for 1Claw. It is designed for CI/CD pipelines, DevOps workflows, and server environments.

## Installation

```bash
npm install -g @1claw/cli
```

Or run with npx:

```bash
npx @1claw/cli login
```

## Authentication

### Browser-based login (recommended)

```bash
1claw login
```

This opens your browser to 1claw.xyz where you approve the login. The CLI polls until you confirm. Your token is stored in `~/.config/1claw/`.

### Email/password

```bash
1claw login --email
```

Supports MFA if enabled on your account.

### CI/CD (non-interactive)

Set environment variables — no login needed:

```bash
export ONECLAW_TOKEN="your-jwt"
# or
export ONECLAW_API_KEY="1ck_..."
export ONECLAW_VAULT_ID="your-vault-uuid"   # optional; required for vault-scoped commands
```

## Main commands

| Area         | Commands                                                                                       |
| ------------ | ---------------------------------------------------------------------------------------------- |
| **Auth**     | `login`, `logout`, `whoami`                                                                    |
| **Vaults**   | `vault list`, `vault create`, `vault get`, `vault link`, `vault delete`                        |
| **Secrets**  | `secret list`, `secret get`, `secret set`, `secret delete`, `secret rotate`, `secret describe` |
| **CI/CD**    | `env pull`, `env push`, `env run -- <command>`                                                 |
| **Agents**   | `agent list`, `agent create`, `agent get`, `agent token`                                       |
| **Policies** | `policy list`, `policy create`, `policy delete`                                                |
| **Sharing**  | `share create`, `share list`, `share accept`, `share revoke`                                   |
| **Billing**  | `billing status`, `billing credits`, `billing usage`                                           |
| **Audit**    | `audit list`                                                                                   |
| **MFA**      | `mfa status`, `mfa enable`, `mfa disable`                                                      |
| **Config**   | `config list`, `config set`, `config get`                                                      |

## CI/CD examples

### GitHub Actions

```yaml
- name: Deploy with secrets
  env:
      ONECLAW_TOKEN: ${{ secrets.ONECLAW_TOKEN }}
      ONECLAW_VAULT_ID: ${{ secrets.ONECLAW_VAULT_ID }}
  run: |
      npx @1claw/cli env pull -o .env.production
      npm run deploy
```

### Run a command with secrets injected

```bash
1claw env run -- npm start
```

Secrets from the linked (or `ONECLAW_VAULT_ID`) vault are injected as environment variables for the child process.

## Configuration

Config file: `~/.config/1claw/config.json`.

- `api-url` — API base URL (default: `https://api.1claw.xyz`)
- `output-format` — `table`, `json`, or `plain`
- `default-vault` — Default vault ID for commands that need one

Use `1claw config list` and `1claw config set <key> <value>` to view and update.

## Device authorization flow

When you run `1claw login` (without `--email`), the CLI:

1. Calls `POST /v1/auth/device/code` to get a device code and user code.
2. Opens the dashboard at `https://1claw.xyz/cli/verify?code=<user_code>`.
3. You approve the request in the browser (while logged in to 1Claw).
4. The CLI polls `POST /v1/auth/device/token` until the backend marks the code approved, then receives a JWT and stores it.

This flow does not require typing your password in the terminal.

## See also

- [JavaScript SDK](/docs/sdks/javascript) — Programmatic access from Node.js or browsers
- [MCP Server](/docs/mcp/overview) — AI agents accessing secrets via tools
- [Two-factor authentication](/docs/security/two-factor-auth) — Optional 2FA for human logins


---

## Crypto Transaction Proxy

---
title: Crypto Transaction Proxy
description: Let agents sign and broadcast blockchain transactions without ever seeing private keys. Includes the full list of supported chains.
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Crypto Transaction Proxy

The Crypto Transaction Proxy lets an agent submit on-chain transactions — transfers, swaps, contract calls — while **never having access to the raw private key**. The server signs the transaction using keys stored in the vault and broadcasts it through a dedicated RPC for the target chain.

## How it works

```
Agent                       1claw Vault                  Blockchain
  │                             │                            │
  │  POST /v1/agents/:id/       │                            │
  │    transactions             │                            │
  │  { chain, to, value,        │                            │
  │    data, signing_key_path } │                            │
  │ ─────────────────────────►  │                            │
  │                             │ 1. Decrypt private key     │
  │                             │    from vault via HSM      │
  │                             │ 2. Build & sign tx         │
  │                             │ 3. Broadcast via RPC  ───► │
  │                             │                            │
  │  ◄───────────────────────── │  tx_hash, status           │
  │  { id, tx_hash, status }    │                            │
```

1. The agent calls `POST /v1/agents/:agent_id/transactions` with the chain, recipient, value, calldata, and the vault path to the signing key.
2. The vault decrypts the private key inside the HSM boundary, constructs and signs the transaction, and broadcasts it to the chain's RPC endpoint.
3. The agent receives an `id` and `tx_hash` — it never sees the raw key material.

## Enabling the proxy

Set `crypto_proxy_enabled: true` when registering or updating an agent:

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/agents" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "DeFi Bot",
    "crypto_proxy_enabled": true
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
import { createClient } from "@1claw/sdk";

const client = createClient({
  baseUrl: "https://api.1claw.xyz",
  apiKey: process.env.ONECLAW_API_KEY,
});

const { data } = await client.agents.create({
  name: "DeFi Bot",
  crypto_proxy_enabled: true,
});
```

</TabItem>
</Tabs>

### What changes when enabled

| Behaviour                        | `crypto_proxy_enabled: false` | `crypto_proxy_enabled: true` |
| -------------------------------- | ----------------------------- | ---------------------------- |
| Read `api_key`, `password`, etc. | Allowed                       | Allowed                      |
| Read `private_key` or `ssh_key`  | Allowed                       | **Blocked (403)**            |
| Submit proxy transactions        | Not available                 | Allowed                      |
| Audit trail per transaction      | N/A                           | Full trace with `tx_id`      |

The enforcement is two-sided: the flag both **grants** access to the transaction endpoints and **blocks** direct reads of signing keys through the standard secrets endpoint. This guarantees the agent can only use keys through the proxy.

## Submitting a transaction

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/agents/$AGENT_ID/transactions" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "chain": "ethereum",
    "to": "0xRecipientAddress",
    "value": "1.0",
    "data": "0x",
    "signing_key_path": "wallets/hot-wallet"
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: tx } = await client.agents.submitTransaction(agentId, {
  chain: "ethereum",
  to: "0xRecipientAddress",
  value: "1.0",
  data: "0x",
  signing_key_path: "wallets/hot-wallet",
});
```

</TabItem>
</Tabs>

### Response

```json
{
    "id": "a7e2c...",
    "tx_hash": "0xabc123...",
    "chain": "ethereum",
    "status": "broadcast"
}
```

## Querying transactions

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
# List all transactions for this agent
curl "https://api.1claw.xyz/v1/agents/$AGENT_ID/transactions" \
  -H "Authorization: Bearer $AGENT_TOKEN"

# Get a specific transaction
curl "https://api.1claw.xyz/v1/agents/$AGENT_ID/transactions/$TX_ID" \
  -H "Authorization: Bearer $AGENT_TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
// List transactions
const { data: txList } = await client.agents.listTransactions(agentId);

// Get transaction
const { data: tx } = await client.agents.getTransaction(agentId, txId);
```

</TabItem>
</Tabs>

## Transaction simulation (Tenderly) {#simulation}

Every transaction can be simulated before signing. Simulation executes the full transaction against the current chain state in a sandboxed environment, returning decoded traces, balance changes, gas estimates, and human-readable error messages — without consuming real gas.

### Standalone simulation

Call the simulate endpoint to preview a transaction without committing:

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/agents/$AGENT_ID/transactions/simulate" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "chain": "base",
    "to": "0xRecipientAddress",
    "value": "0.5",
    "data": "0x",
    "signing_key_path": "wallets/hot-wallet"
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: sim } = await client.agents.simulateTransaction(agentId, {
  chain: "base",
  to: "0xRecipientAddress",
  value: "0.5",
  data: "0x",
  signing_key_path: "wallets/hot-wallet",
});
```

</TabItem>
</Tabs>

The response includes:

```json
{
  "simulation_id": "sim_a7e2c...",
  "status": "success",
  "gas_used": 21000,
  "balance_changes": [
    { "address": "0xSender...", "token": "ETH", "before": "2.5", "after": "1.99", "change": "-0.51" },
    { "address": "0xRecipient...", "token": "ETH", "before": "0.0", "after": "0.5", "change": "+0.5" }
  ],
  "tenderly_dashboard_url": "https://dashboard.tenderly.co/..."
}
```

### Simulate-then-sign (single call)

Add `"simulate_first": true` to the standard transaction submission. The server simulates first; if the simulation reverts, it returns HTTP 422 and does **not** sign or broadcast:

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/agents/$AGENT_ID/transactions" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "chain": "base",
    "to": "0xRecipientAddress",
    "value": "0.5",
    "simulate_first": true
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: tx } = await client.agents.submitTransaction(agentId, {
  chain: "base",
  to: "0xRecipientAddress",
  value: "0.5",
  simulate_first: true,
});
```

</TabItem>
</Tabs>

### Bundle simulation

Simulate multiple transactions sequentially (e.g. ERC-20 approve followed by a swap):

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/agents/$AGENT_ID/transactions/simulate-bundle" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "transactions": [
      { "chain": "base", "to": "0xToken", "value": "0", "data": "0xapprove..." },
      { "chain": "base", "to": "0xRouter", "value": "0", "data": "0xswap..." }
    ]
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: bundle } = await client.agents.simulateBundle(agentId, {
  transactions: [
    { chain: "base", to: "0xToken", value: "0", data: "0xapprove..." },
    { chain: "base", to: "0xRouter", value: "0", data: "0xswap..." },
  ],
});
```

</TabItem>
</Tabs>

### Enforcing simulation

Org admins can require simulation for all agent transactions by setting the `crypto_proxy.require_simulation` org setting to `"true"` via `PUT /v1/admin/settings/crypto_proxy.require_simulation`. When enabled, any transaction submitted without `simulate_first: true` will be automatically simulated, and reverts will block signing.

### EIP-1559 (Type 2) transactions

Set `max_fee_per_gas` and `max_priority_fee_per_gas` instead of `gas_price` to use EIP-1559 fee mode:

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/agents/$AGENT_ID/transactions" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "chain": "base",
    "to": "0xRecipientAddress",
    "value": "0.1",
    "max_fee_per_gas": "30000000000",
    "max_priority_fee_per_gas": "1500000000",
    "simulate_first": true
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: tx } = await client.agents.submitTransaction(agentId, {
  chain: "base",
  to: "0xRecipientAddress",
  value: "0.1",
  max_fee_per_gas: "30000000000",
  max_priority_fee_per_gas: "1500000000",
  simulate_first: true,
});
```

</TabItem>
</Tabs>

## MCP tools

The MCP server provides two transaction tools:

**`simulate_transaction`** — simulate without signing:
```
Tool: simulate_transaction
Args:
  chain: "base"
  to: "0xRecipientAddress"
  value: "0.5"
  signing_key_path: "wallets/hot-wallet"
```

**`submit_transaction`** — sign and broadcast (simulation on by default):
```
Tool: submit_transaction
Args:
  chain: "base"
  to: "0xRecipientAddress"
  value: "0.5"
  signing_key_path: "wallets/hot-wallet"
  simulate_first: true
```

---

## Supported chains {#supported-chains}

The proxy can broadcast transactions to any chain in the registry. All mainnet chains below are configured with dedicated dRPC endpoints for reliable transaction delivery.

:::tip Querying chains via API
You can always fetch the live list with `GET /v1/chains`. The response includes `chain_id`, `rpc_url`, `explorer_url`, and `native_currency` for every chain.
:::

### Mainnet chains (28)

| Chain             | Chain ID | Native token | Explorer                                                           |
| ----------------- | -------- | ------------ | ------------------------------------------------------------------ |
| Ethereum          | 1        | ETH          | [etherscan.io](https://etherscan.io)                               |
| Optimism          | 10       | ETH          | [optimistic.etherscan.io](https://optimistic.etherscan.io)         |
| Cronos            | 25       | CRO          | [cronoscan.com](https://cronoscan.com)                             |
| BNB Smart Chain   | 56       | BNB          | [bscscan.com](https://bscscan.com)                                 |
| Gnosis            | 100      | xDAI         | [gnosisscan.io](https://gnosisscan.io)                             |
| Polygon           | 137      | POL          | [polygonscan.com](https://polygonscan.com)                         |
| Sonic             | 146      | S            | [sonicscan.org](https://sonicscan.org)                             |
| Fantom            | 250      | FTM          | [ftmscan.com](https://ftmscan.com)                                 |
| zkSync Era        | 324      | ETH          | [explorer.zksync.io](https://explorer.zksync.io)                   |
| World Chain       | 480      | ETH          | [worldscan.org](https://worldscan.org)                             |
| Metis             | 1088     | METIS        | [andromeda-explorer.metis.io](https://andromeda-explorer.metis.io) |
| Polygon zkEVM     | 1101     | ETH          | [zkevm.polygonscan.com](https://zkevm.polygonscan.com)             |
| Moonbeam          | 1284     | GLMR         | [moonscan.io](https://moonscan.io)                                 |
| Sei               | 1329     | SEI          | [seitrace.com](https://seitrace.com)                               |
| Mantle            | 5000     | MNT          | [mantlescan.xyz](https://mantlescan.xyz)                           |
| Kaia              | 8217     | KAIA         | [kaiascan.io](https://kaiascan.io)                                 |
| Base              | 8453     | ETH          | [basescan.org](https://basescan.org)                               |
| Mode              | 34443    | ETH          | [modescan.io](https://modescan.io)                                 |
| Arbitrum One      | 42161    | ETH          | [arbiscan.io](https://arbiscan.io)                                 |
| Arbitrum Nova     | 42170    | ETH          | [nova.arbiscan.io](https://nova.arbiscan.io)                       |
| Celo              | 42220    | CELO         | [celoscan.io](https://celoscan.io)                                 |
| Avalanche C-Chain | 43114    | AVAX         | [snowtrace.io](https://snowtrace.io)                               |
| Linea             | 59144    | ETH          | [lineascan.build](https://lineascan.build)                         |
| Berachain         | 80094    | BERA         | [berascan.com](https://berascan.com)                               |
| Blast             | 81457    | ETH          | [blastscan.io](https://blastscan.io)                               |
| Taiko             | 167000   | ETH          | [taikoscan.io](https://taikoscan.io)                               |
| Scroll            | 534352   | ETH          | [scrollscan.com](https://scrollscan.com)                           |
| Zora              | 7777777  | ETH          | [explorer.zora.energy](https://explorer.zora.energy)               |

### Testnet chains

| Chain        | Chain ID | Native token |
| ------------ | -------- | ------------ |
| Sepolia      | 11155111 | ETH          |
| Base Sepolia | 84532    | ETH          |

### Adding a chain

Admins can add new chains via the admin API:

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/admin/chains" \
  -H "Authorization: Bearer $ADMIN_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "my-chain",
    "display_name": "My Chain",
    "chain_id": 12345,
    "rpc_url": "https://rpc.mychain.io",
    "explorer_url": "https://explorer.mychain.io",
    "native_currency": "MCH"
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
// Admin chain management requires direct API calls
const response = await fetch("https://api.1claw.xyz/v1/admin/chains", {
  method: "POST",
  headers: {
    "Authorization": `Bearer ${adminToken}`,
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    name: "my-chain",
    display_name: "My Chain",
    chain_id: 12345,
    rpc_url: "https://rpc.mychain.io",
    explorer_url: "https://explorer.mychain.io",
    native_currency: "MCH",
  }),
});
```

</TabItem>
</Tabs>

See the [Admin API reference](/docs/reference/api-reference#admin) for update and delete endpoints.

---

## Transaction guardrails

Per-agent controls can be set when registering or updating an agent to limit what transactions the proxy will sign:

| Field | Type | Description |
| ----- | ---- | ----------- |
| `tx_allowed_chains` | `string[]` | Restrict to specific chain names (e.g. `["ethereum", "base"]`). Empty = all chains allowed. |
| `tx_to_allowlist` | `string[]` | Restrict recipient addresses. Empty = any address allowed. |
| `tx_max_value_eth` | `string` | Maximum value per transaction in ETH (e.g. `"1.0"`). Null = no per-tx limit. |
| `tx_daily_limit_eth` | `string` | Rolling 24-hour spend limit in ETH. Null = no daily limit. |

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X PATCH "https://api.1claw.xyz/v1/agents/$AGENT_ID" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "tx_allowed_chains": ["ethereum", "base"],
    "tx_to_allowlist": ["0xSafeAddress1", "0xSafeAddress2"],
    "tx_max_value_eth": "0.5",
    "tx_daily_limit_eth": "5.0"
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: agent } = await client.agents.update(agentId, {
  tx_allowed_chains: ["ethereum", "base"],
  tx_to_allowlist: ["0xSafeAddress1", "0xSafeAddress2"],
  tx_max_value_eth: "0.5",
  tx_daily_limit_eth: "5.0",
});
```

</TabItem>
</Tabs>

When a transaction violates any guardrail, the proxy returns **403 Forbidden** with a descriptive `detail` message.

---

## Security model

- **Keys never leave the HSM boundary** — the vault decrypts the key, signs the transaction, and zeroes the memory. The plaintext key is never returned to the caller.
- **Full audit trail** — every transaction is logged with the agent ID, chain, recipient, value, and resulting `tx_hash`.
- **Policy enforcement** — the agent still needs a policy granting access to the vault path that holds the signing key. The proxy doesn't bypass access control.
- **Transaction guardrails** — per-agent chain allowlists, recipient allowlists, per-tx caps, and daily spend limits enforced server-side before signing.
- **Rate limiting** — standard rate limits apply to transaction endpoints.

## Replay protection

### Idempotency-Key header

Submit an `Idempotency-Key` header (e.g. a UUID) with `POST /v1/agents/:id/transactions` to prevent duplicate submissions. If the same key is sent within 24 hours, the server returns the cached transaction response instead of signing and broadcasting again.

The SDK and MCP server auto-generate an idempotency key on every `submitTransaction` call. You can override with your own key for explicit retry control.

| Scenario | Response |
| --- | --- |
| First request with key | `201 Created` (normal flow) |
| Duplicate request (completed) | `200 OK` (cached response) |
| Duplicate request (in progress) | `409 Conflict` (retry later) |
| No header | No idempotency enforcement |

### Server-side nonce management

When the `nonce` field is omitted, the server atomically reserves the next nonce per agent+chain+address combination. This prevents nonce collisions when multiple transactions are submitted concurrently. The server tracks the highest nonce used and takes the maximum of its tracked value and the on-chain pending nonce.

### Response field gating

By default, the `signed_tx` field (raw signed transaction hex) is **omitted** from GET responses to reduce exfiltration risk. Pass `?include_signed_tx=true` to include it:

```bash
curl "https://api.1claw.xyz/v1/agents/$AGENT_ID/transactions?include_signed_tx=true" \
  -H "Authorization: Bearer $AGENT_TOKEN"
```

The initial POST submission always returns `signed_tx` for the originating caller.

## Best practices

1. **One key per agent** — give each agent its own signing key in its own vault path so you can revoke independently.
2. **Set `expires_at`** — register agents with an expiry so leaked API keys have a bounded blast radius.
3. **Use scoped policies** — grant the agent access only to the specific vault path containing its signing key, not the entire vault.
4. **Monitor transactions** — query `GET /v1/agents/:id/transactions` regularly or set up audit webhooks.
5. **Use testnets first** — store a testnet key (Sepolia, Base Sepolia) and verify the flow before moving to mainnet.


---

## Customer-Managed Encryption Keys (CMEK)

---
title: Customer-Managed Encryption Keys (CMEK)
description: Add a client-side AES-256-GCM encryption layer on top of HSM envelope encryption. Your key never touches the server.
sidebar_position: 5
---

# Customer-Managed Encryption Keys (CMEK)

CMEK adds a **client-side encryption layer** on top of 1claw's HSM-backed envelope encryption. Your key never touches 1claw servers — only its SHA-256 fingerprint is stored so the vault can track which key was used.

## Who this is for

CMEK is designed for organizations that require **cryptographic proof that 1claw cannot access their secrets unilaterally**. If you don't have this requirement, the default HSM encryption is already strong — every vault gets its own KEK in the HSM, every secret version gets a fresh DEK, and plaintext keys exist only in memory during crypto operations.

CMEK is available on **Business** and **Enterprise** plans.

## How it works

When CMEK is enabled on a vault, secrets are double-encrypted:

1. **Client-side**: You encrypt the secret value with your CMEK key (AES-256-GCM) before it reaches the server.
2. **Server-side**: 1claw applies its standard HSM envelope encryption on top.

At rest, each secret is wrapped in two independent encryption layers. A full server compromise yields only doubly-encrypted blobs — useless without your CMEK key.

### Wire format

```
[1 byte version = 0x01][12 bytes IV][N bytes ciphertext][16 bytes GCM auth tag]
```

The version byte allows future algorithm changes without breaking existing secrets.

## API endpoints

| Method | Path | Description |
| ------ | ---- | ----------- |
| POST | `/v1/vaults/:vault_id/cmek` | Enable CMEK (send fingerprint only) |
| DELETE | `/v1/vaults/:vault_id/cmek` | Disable CMEK |
| POST | `/v1/vaults/:vault_id/cmek-rotate` | Start key rotation (old+new keys in headers) |
| GET | `/v1/vaults/:vault_id/cmek-rotate/:job_id` | Poll rotation job status |

## Enabling CMEK

### Dashboard

1. Navigate to your vault → **Settings** tab
2. Click **Enable CMEK** in the Customer-Managed Key card
3. A 256-bit AES key is generated **in your browser** via WebCrypto
4. Download the `.key` file and store it safely (password manager, hardware key, etc.)
5. Confirm you've saved the key, then click **Enable CMEK**

Only the key's SHA-256 fingerprint is sent to the server.

### SDK

```typescript
import {
  generateCmekKey,
  cmekFingerprint,
  toBase64,
} from "@1claw/sdk";

// Generate a key (runs in browser or Node.js 18+)
const key = await generateCmekKey();
const fingerprint = await cmekFingerprint(key);

// Store the key safely — you'll need it for every read/write
console.log("Key (base64):", toBase64(key));
console.log("Fingerprint:", fingerprint);

// Enable CMEK on the vault
await client.vault.enableCmek(vaultId, { fingerprint });
```

### CLI

```bash
# The CLI does not generate keys — use the dashboard or SDK.
# You can check CMEK status via the vault detail:
1claw vault get <vault-id>
```

## Reading and writing secrets

When a vault has CMEK enabled, you must encrypt values before writing and decrypt after reading.

### SDK

```typescript
import {
  cmekEncrypt,
  cmekDecrypt,
  toBase64,
  fromBase64,
} from "@1claw/sdk";

// Write: encrypt before sending
const plaintext = new TextEncoder().encode("my-secret-value");
const encrypted = await cmekEncrypt(plaintext, cmekKey);
await client.secrets.put(vaultId, "api-keys/stripe", {
  type: "api_key",
  value: toBase64(encrypted),
});

// Read: decrypt after receiving
const { data } = await client.secrets.get(vaultId, "api-keys/stripe");
if (data?.cmek_encrypted) {
  const blob = fromBase64(data.value);
  const decrypted = await cmekDecrypt(blob, cmekKey);
  const value = new TextDecoder().decode(decrypted);
  console.log(value); // "my-secret-value"
}
```

The `cmek_encrypted` flag on the response tells you whether the value needs client-side decryption.

## Key rotation

Over time, you may need to rotate your CMEK key (policy requirements, suspected compromise, etc.). 1claw supports **server-assisted rotation** that handles large vaults efficiently.

### How server-assisted rotation works

1. You provide the old key and the new key via HTTP headers (TLS-protected)
2. The server processes secrets in batches of 100, atomically per batch
3. Each secret is: HSM-decrypted → CMEK-decrypted with old key → CMEK-encrypted with new key → HSM-encrypted
4. Progress is tracked in a rotation job — you can poll for status
5. If interrupted, the rotation can be resumed (each secret tracks its CMEK fingerprint)

Both keys exist in server memory **only during the rotation operation** and are discarded immediately after.

### SDK

```typescript
const { data: job } = await client.vault.rotateCmek(
  vaultId,
  toBase64(oldKey),
  toBase64(newKey),
  newFingerprint,
);

// Poll for completion
let status = job;
while (status?.status === "running") {
  await new Promise((r) => setTimeout(r, 2000));
  const res = await client.vault.getRotationJobStatus(vaultId, job!.id);
  status = res.data;
  console.log(`Progress: ${status?.processed}/${status?.total_secrets}`);
}
```

### Trade-off

During rotation, both keys are in server memory for the duration of the operation. If your threat model excludes **any** server-side key presence, perform rotation client-side via the SDK by reading each secret, decrypting with the old key, re-encrypting with the new key, and writing back.

## Agent considerations

For agents, CMEK means storing the key in the agent's environment (e.g., `ONECLAW_CMEK_KEY` env var). This is appropriate when the agent operator has secure infrastructure for managing that key.

**For most agent use cases, vault binding and short-lived tokens (Phase 1) provide sufficient security without key management overhead.** See the [Securing Agent Access](./securing-agent-access) guide.

If you do use CMEK with agents:

- Store the CMEK key in a secure secret manager or hardware-bound store
- Use the SDK's `cmekEncrypt` / `cmekDecrypt` functions in your agent code
- Consider Phase 3 (KMS-delegated team keys) when available — it eliminates raw key material from agent environments entirely

## What CMEK protects against

| Threat | Protected? |
|--------|-----------|
| 1claw server compromise | Yes — attacker gets doubly-encrypted blobs |
| 1claw operator reading secrets | Yes — operator cannot decrypt without your key |
| Database backup theft | Yes — backups contain only encrypted data |
| Your CMEK key leaked | No — attacker with key + API access can read secrets |
| Compromised agent environment | Partially — depends on how the key is stored |

## Disabling CMEK

You can disable CMEK on a vault at any time. New secrets will use HSM-only encryption. Existing CMEK-encrypted secrets **still require the key to decrypt** — disabling only affects new writes.


---

## Deploying Updates

---
title: Deploying Updates
description: How to deploy updates to each component of the 1claw stack — vault API, dashboard, docs, and MCP server.
sidebar_position: 6
---

# Deploying Updates

Every component of 1claw auto-deploys on push to `main`. This guide explains how each deployment works and how to trigger manual deploys.

## Auto-deploy on push

| Component | Path trigger | Deploys to | Workflow |
|-----------|-------------|------------|----------|
| Vault API | `vault/**` | Cloud Run (`oneclaw-vault`) | `.github/workflows/deploy-vault.yml` |
| MCP Server | `packages/mcp/**` | Cloud Run (`oneclaw-mcp`) | `.github/workflows/deploy-mcp.yml` |
| Dashboard | `dashboard/**` | Vercel (`1claw.xyz`) | Vercel Git integration |
| Docs | `docs/**` | Vercel (`docs.1claw.xyz`) | Vercel Git integration |

## Vault API

The vault is a Rust binary deployed as a Docker container on Cloud Run.

### Auto-deploy flow

1. Push to `main` with changes in `vault/`.
2. GitHub Actions builds a Docker image (`linux/amd64`).
3. Image is pushed to Artifact Registry.
4. Cloud Run service `oneclaw-vault` is updated.

### Manual deploy

```bash
# From repo root
IMAGE="us-west1-docker.pkg.dev/YOUR_PROJECT/oneclaw/vault"
docker build --platform linux/amd64 -f vault/Dockerfile -t "$IMAGE:latest" vault/
docker push "$IMAGE:latest"
gcloud run services update oneclaw-vault --region us-west1 --image "$IMAGE:latest"
```

### Required GitHub secrets

| Secret | Value |
|--------|-------|
| `GCP_PROJECT_ID` | Your GCP project ID |
| `GCP_WORKLOAD_IDENTITY_PROVIDER` | Workload Identity Federation provider |
| `GCP_SERVICE_ACCOUNT` | Service account email |

## MCP Server

The MCP server is a Node.js app deployed as a Docker container on Cloud Run.

### Auto-deploy flow

1. Push to `main` with changes in `packages/mcp/`.
2. GitHub Actions builds a Docker image.
3. Image is pushed to Artifact Registry.
4. Cloud Run service `oneclaw-mcp` is updated.

### Manual deploy

```bash
IMAGE="us-west1-docker.pkg.dev/YOUR_PROJECT/oneclaw/mcp"
docker build --platform linux/amd64 -f packages/mcp/Dockerfile -t "$IMAGE:latest" packages/mcp/
docker push "$IMAGE:latest"
gcloud run services update oneclaw-mcp --region us-west1 --image "$IMAGE:latest"
```

Uses the same GitHub secrets as the vault.

## Dashboard

The Next.js dashboard is deployed to Vercel via Git integration.

### Auto-deploy flow

1. Push to `main` with changes in `dashboard/`.
2. Vercel detects the change and builds automatically.
3. Production deployment goes live at `1claw.xyz`.

### Manual deploy

```bash
cd dashboard
npx vercel --prod
```

### Vercel project settings

| Setting | Value |
|---------|-------|
| Root Directory | `dashboard` |
| Framework | Next.js |
| Build Command | `pnpm build` |

## Docs

The Docusaurus docs site is deployed to Vercel via Git integration.

### Auto-deploy flow

1. Push to `main` with changes in `docs/`.
2. Vercel detects the change and builds automatically.
3. Production deployment goes live at `docs.1claw.xyz`.

### Manual deploy

```bash
cd docs
npx vercel --prod
```

### Vercel project settings

| Setting | Value |
|---------|-------|
| Root Directory | `docs` |
| Build Command | `pnpm run build` |
| Output Directory | `build` |

## Infrastructure changes

Changes to `infra/` (Terraform) are not auto-deployed. Apply manually:

```bash
cd infra
terraform plan    # Review changes
terraform apply   # Apply
```

This is intentional — infrastructure changes should be reviewed before applying.


---

## Email Notifications

---
title: Email Notifications
description: 1Claw sends transactional emails for important account events via Resend.
sidebar_position: 9
---

# Email Notifications

1Claw sends transactional email notifications for important security and account events. Emails are powered by [Resend](https://resend.com) and are sent asynchronously — they never block API responses.

## Notification events

| Event                      | Recipient       | When                                                            |
| -------------------------- | --------------- | --------------------------------------------------------------- |
| **Welcome**                | New user        | Account created via email/password signup or Google OAuth       |
| **Secret shared**          | Share recipient | A secret is shared with them via email (`external_email` share) |
| **Shared secret accessed** | Share creator   | Someone accesses a secret the user shared                       |
| **Password changed**       | User            | Password is successfully changed                                |
| **API key created**        | User            | A new personal API key is created on their account              |

## Configuration

Email sending requires a Resend API key. Set these environment variables on the vault server:

| Variable             | Required | Default                     | Description                    |
| -------------------- | -------- | --------------------------- | ------------------------------ |
| `RESEND_API_KEY`     | Yes      | —                           | Your Resend API key (`re_...`) |
| `ONECLAW_EMAIL_FROM` | No       | `1Claw <noreply@1claw.xyz>` | Sender address                 |
| `ONECLAW_PUBLIC_URL` | No       | `https://1claw.xyz`         | Base URL for links in emails   |

If `RESEND_API_KEY` is not set, email sending is silently skipped and a log message is emitted instead. This is useful for local development.

## Self-hosting

If you're self-hosting 1Claw:

1. Create a free [Resend](https://resend.com) account.
2. Add and verify your domain in Resend.
3. Create an API key and set `RESEND_API_KEY` in your environment.
4. Set `ONECLAW_EMAIL_FROM` to a sender address on your verified domain.
5. Set `ONECLAW_PUBLIC_URL` to your dashboard URL so email links work correctly.

## Email design

All emails use inline CSS for maximum email client compatibility. They follow a dark theme consistent with the 1Claw brand and include:

- Clear subject lines describing the event
- Action buttons linking to the dashboard
- Footer with support contact information


---

## Give an agent access

---
title: Give an agent access
description: "End-to-end walkthrough: create a vault and secret, register an agent, create a policy granting read, then have the agent fetch the secret."
sidebar_position: 0
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Give an agent access

This is the **golden path**: you create a secret, register an agent, grant it read access via a policy, then the agent fetches the secret at runtime.

## 1. Create a vault and secret (human)

Log in (email/password or Google), then:

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
# Get token (see Quickstart for humans)
export TOKEN="..."

# Create vault
VAULT_RESP=$(curl -s -X POST https://api.1claw.xyz/v1/vaults \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"Production","description":"Prod secrets"}')
VAULT_ID=$(echo "$VAULT_RESP" | jq -r '.id')

# Store a secret
curl -s -X PUT "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"api_key","value":"sk-proj-..."}'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
import { createClient } from "@1claw/sdk";

const client = createClient({
  baseUrl: "https://api.1claw.xyz",
  apiKey: process.env.ONECLAW_API_KEY,
});

const { data: vault } = await client.vault.create({
  name: "Production",
  description: "Prod secrets",
});

await client.secrets.set(vault.id, "api-keys/openai", "sk-proj-...", {
  type: "api_key",
});
```

</TabItem>
</Tabs>

## 2. Register an agent (human)

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
AGENT_RESP=$(curl -s -X POST https://api.1claw.xyz/v1/agents \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"My Bot","description":"CI agent","scopes":["vaults:read"]}')
AGENT_ID=$(echo "$AGENT_RESP" | jq -r '.agent.id')
API_KEY=$(echo "$AGENT_RESP" | jq -r '.api_key')
# Store API_KEY securely; it is shown only once.
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data } = await client.agents.create({
  name: "My Bot",
  description: "CI agent",
  scopes: ["vaults:read"],
});
const agentId = data.agent.id;
const apiKey = data.api_key; // Store securely — shown only once
```

</TabItem>
</Tabs>

## 3. Create a policy (human)

Grant the agent read access to all secrets in the vault (or use a narrower pattern like `api-keys/*`):

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s -X POST "https://api.1claw.xyz/v1/vaults/$VAULT_ID/policies" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d "{
    \"secret_path_pattern\": \"**\",
    \"principal_type\": \"agent\",
    \"principal_id\": \"$AGENT_ID\",
    \"permissions\": [\"read\"]
  }"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.access.grantAgent({
  vault_id: vault.id,
  secret_path_pattern: "**",
  principal_id: agentId,
  permissions: ["read"],
});
```

</TabItem>
</Tabs>

## 4. Agent fetches the secret

From the agent's environment (with `AGENT_ID` and `API_KEY` stored securely):

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
# Get agent JWT
AGENT_TOKEN=$(curl -s -X POST https://api.1claw.xyz/v1/auth/agent-token \
  -H "Content-Type: application/json" \
  -d "{\"agent_id\":\"$AGENT_ID\",\"api_key\":\"$API_KEY\"}" | jq -r '.access_token')

# Fetch secret
curl -s "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $AGENT_TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
import { createClient } from "@1claw/sdk";

// In the agent's runtime
const agentClient = createClient({
  baseUrl: "https://api.1claw.xyz",
  agentId: process.env.ONECLAW_AGENT_ID,
  apiKey: process.env.ONECLAW_AGENT_API_KEY,
});

const { data: secret } = await agentClient.secrets.get(VAULT_ID, "api-keys/openai");
// Use secret.value — don't log or persist
```

</TabItem>
</Tabs>

The response includes the decrypted `value`. The agent uses it for the intended call and does not persist or log it.

## Summary

| Step | Who   | Action |
|------|--------|--------|
| 1    | Human | Create vault, store secret |
| 2    | Human | Register agent, save API key |
| 3    | Human | Create policy: agent + path pattern + read |
| 4    | Agent | Get token, GET secret by path |

To revoke: delete the policy or deactivate the agent. To rotate: create a new secret version (PUT) or rotate the agent key.


---

## MCP Integration

---
title: MCP integration
description: Connect AI agents to your 1claw vault using the Model Context Protocol. Hosted at mcp.1claw.xyz or run locally via stdio.
sidebar_position: 4
---

# MCP Integration

The 1claw MCP server gives AI agents (Claude, Cursor, GPT, and others) secure, just-in-time access to secrets stored in your vault via the [Model Context Protocol](https://modelcontextprotocol.io).

## Quick start (hosted)

The fastest way to connect an AI agent to your vault:

1. **Register an agent** in the [1claw dashboard](https://1claw.xyz/agents/new) — save the API key (`ocv_...`).
2. **Create a policy** granting the agent `read` access to the paths it needs.
3. **Get a JWT** by calling the agent-token endpoint with your agent ID and API key:
   ```bash
   curl -s -X POST https://api.1claw.xyz/v1/auth/agent-token \
     -H "Content-Type: application/json" \
     -d '{"agent_id":"<uuid>","api_key":"ocv_..."}' | jq -r '.access_token'
   ```
4. **Configure your MCP client** with the hosted server (use the JWT from step 3 as the Bearer token; it expires in ~1 hour):

```json
{
  "mcpServers": {
    "1claw": {
      "url": "https://mcp.1claw.xyz/mcp",
      "headers": {
        "Authorization": "Bearer <jwt-from-agent-token-endpoint>",
        "X-Vault-ID": "your-vault-uuid"
      }
    }
  }
}
```

That's it. The agent can now call `list_secrets`, `get_secret`, and other tools.

## Quick start (local)

For local/air-gapped setups, run the MCP server via stdio. Use **agent ID + API key** so the server can refresh the JWT automatically:

```bash
cd packages/mcp && pnpm install && pnpm run build
```

```json
{
  "mcpServers": {
    "1claw": {
      "command": "node",
      "args": ["/path/to/packages/mcp/dist/index.js"],
      "env": {
        "ONECLAW_AGENT_ID": "your-agent-uuid",
        "ONECLAW_AGENT_API_KEY": "ocv_your_agent_api_key",
        "ONECLAW_VAULT_ID": "your-vault-uuid"
      }
    }
  }
}
```

## Available tools

| Tool | What it does |
|------|-------------|
| `list_secrets` | List all secrets (metadata only, never values) |
| `get_secret` | Fetch decrypted value by path |
| `put_secret` | Create or update a secret |
| `delete_secret` | Soft-delete a secret |
| `describe_secret` | Get metadata without the value |
| `rotate_and_store` | Store a new version of an existing secret |
| `get_env_bundle` | Fetch and parse a KEY=VALUE env bundle |

## Typical agent workflow

1. **Discover** — `list_secrets` to see what's available.
2. **Check** — `describe_secret` to verify it exists and hasn't expired.
3. **Fetch** — `get_secret` to get the decrypted value.
4. **Use** — Pass the value into the API call.
5. **Forget** — Do not store the value in summaries, logs, or memory.

## Security

- Secrets are fetched just-in-time and never cached by the MCP server.
- Secret values are never logged — only the path is recorded.
- Each hosted connection authenticates independently (per-session isolation).
- All access is recorded in the vault audit log.

## Further reading

- [MCP Server Overview](/docs/mcp/overview) — Architecture and how it works
- [Setup Guide](/docs/mcp/setup) — Detailed config for Claude Desktop, Cursor, and more
- [Tool Reference](/docs/mcp/tools) — Parameters, examples, and errors for each tool
- [Security Model](/docs/mcp/security) — Threat model and best practices
- [Deployment](/docs/mcp/deployment) — Deploy your own hosted MCP server


---

## Using 1claw with OpenClaw

---
title: Using 1claw with OpenClaw
description: Add the 1claw skill to your OpenClaw gateway so your AI agent can store and retrieve secrets from the vault.
sidebar_position: 7
---

# Using 1claw with OpenClaw

[OpenClaw](https://docs.openclaw.ai) is a self-hosted gateway that connects chat apps (WhatsApp, Telegram, Discord, iMessage, and more) to AI coding agents. The **1claw skill** lets your OpenClaw agent use the 1Claw vault to store, retrieve, rotate, and share secrets — so the agent can use API keys and credentials at runtime without them ever living in chat or context.

## What you get

With the 1claw skill installed, your OpenClaw agent can:

- List and fetch secrets from a 1Claw vault by path
- Store new secrets or rotate existing ones
- Share secrets with users or other agents
- Create vaults and grant access (subject to policies)
- Sign or simulate EVM transactions via the crypto proxy (if enabled for the agent)

Secrets are encrypted in the vault and fetched just-in-time; they are not persisted in the conversation.

## Prerequisites

1. **1Claw account** — Sign up at [1claw.xyz](https://1claw.xyz).
2. **A vault** — Create a vault in the dashboard (or via API).
3. **An agent** — Register an agent in the dashboard (Vaults → select vault → Agents, or from the Agents page). Copy the **Agent ID** and the one-time **API key** (`ocv_...`); store the key securely.
4. **Access for the agent** — Grant the agent read (and optionally write) access to the vault via a policy. See [Give an agent access](/docs/guides/give-agent-access).

## Install the 1claw skill

Install the skill using the ClawHub CLI:

```bash
clawhub install 1claw
```

This installs the 1claw skill so your OpenClaw gateway can use 1Claw for secret management.

## Configure credentials

The 1claw skill expects these environment variables (or equivalent in your OpenClaw config):

| Variable | Description |
| -------- | ----------- |
| `ONECLAW_AGENT_ID` | Your 1Claw agent's UUID (from the dashboard). |
| `ONECLAW_AGENT_API_KEY` | The agent's API key (`ocv_...`). Created when you register the agent; rotate from the dashboard if needed. |
| `ONECLAW_VAULT_ID` | The vault UUID the agent will read from and write to. |

Set them in your OpenClaw environment or in the config your gateway uses when running the 1claw MCP server (the skill uses the [1Claw MCP server](https://www.npmjs.com/package/@1claw/mcp) under the hood).

## How it works

The 1claw skill teaches your agent how to call 1Claw's MCP tools (e.g. `list_secrets`, `get_secret`, `put_secret`, `create_vault`, `share_secret`). When the agent needs a credential, it calls the tool; the MCP server authenticates to the 1Claw API with your agent credentials and returns the secret value. The agent uses it for the task and does not store it in long-term context.

- **MCP server** — The skill uses `@1claw/mcp`. You can run it as a local process (stdio) or use the hosted MCP at `https://mcp.1claw.xyz/mcp` if your OpenClaw setup supports remote MCP.
- **Permissions** — The agent's 1Claw policies control what it can read and write. Restrict by path pattern (e.g. `prod/*` only) and use the dashboard to revoke or rotate access anytime.

## Next steps

- [OpenClaw documentation](https://docs.openclaw.ai) — Gateway setup, channels, and configuration.
- [MCP Server](/docs/mcp/overview) — 1Claw MCP tools and setup in detail.
- [Give an agent access](/docs/guides/give-agent-access) — Create policies so your agent can access the right vault and paths.
- [Skill repository](https://github.com/1clawAI/1claw/tree/main/skill) — Skill source (SKILL.md, EXAMPLES.md, CONFIG.md) and validation script.


---

## Revoking access

---
title: Revoking access
description: Revoke agent or user access by deleting the policy, or deactivate the agent; access is enforced on every request.
sidebar_position: 3
---

# Revoking access

Access is checked on **every request**. Revocation takes effect as soon as you remove the grant or deactivate the agent.

## Remove a policy (grant)

**DELETE /v1/vaults/:vault_id/policies/:policy_id**

The principal (user or agent) immediately loses the permissions that policy granted. No cache; the next request fails with 403 if no other policy applies.

## Deactivate an agent

**DELETE /v1/agents/:agent_id**

The agent is marked inactive. It can no longer exchange its API key for a JWT. Existing JWTs may still work until they expire (typically short-lived). For immediate effect, rotate the agent key (so the old key fails) and/or keep token lifetime short.

## Rotate agent key

**POST /v1/agents/:agent_id/rotate-key**

Returns a new API key; the old one stops working. Use this to invalidate a leaked key without deactivating the agent.


---

## Rotating secrets

---
title: Rotating secrets
description: Create a new version with PUT to the same path; optionally use expires_at or max_access_count to limit exposure.
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rotating secrets

1claw does not yet expose a dedicated "rotate" endpoint that returns a new value from a provider. Rotation is done by **creating a new version** of the secret.

## Steps

1. Generate or obtain the new value (e.g. new API key from OpenAI, new DB password).
2. **PUT** to the same vault and path with the new value (see [Create/update](/docs/human-api/secrets/create)).
3. Update any consumers to use the new value (or rely on "latest" version).
4. Optionally revoke or expire the old value at the external provider.

## How to rotate

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
# Generate the new value, then store it at the same path
curl -X PUT "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"api_key","value":"sk-proj-NEW..."}'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
// PUT to the same path creates a new version automatically
await client.secrets.set(vaultId, "api-keys/openai", "sk-proj-NEW...", {
  type: "api_key",
});
```

</TabItem>
</Tabs>

## Optional: limit exposure

- Set **expires_at** on the secret so it becomes unavailable after a date.
- Set **max_access_count** so the secret stops being returned after N reads (e.g. one-time use).

## Agent tokens

To rotate an **agent API key**, use **POST /v1/agents/:agent_id/rotate-key**. The response includes the new key once; update the agent's config and discard the old key.

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/agents/$AGENT_ID/rotate-key" \
  -H "Authorization: Bearer $TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data } = await client.agents.rotateKey(agentId);
console.log(data.api_key); // New key — store securely
```

</TabItem>
</Tabs>


---

## Scoped permissions

---
title: Scoped permissions
description: Use path patterns and principal_type in policies to grant minimal read or write access to specific secrets.
sidebar_position: 2
---

# Scoped permissions

Policies tie a **principal** (user or agent) to **path patterns** and **permissions**. Use narrow patterns and only the permissions needed.

## Path patterns

- `**` — All paths in the vault (read or write depending on permissions).
- `api-keys/*` — Only paths under `api-keys/` (e.g. `api-keys/openai`, `api-keys/stripe`).
- `prod/db` — Exact path `prod/db` only.

Patterns use glob rules: `*` matches one segment, `**` matches zero or more segments. Give agents the smallest set of paths they need.

## Permissions

- **read** — Can GET secret value and list (metadata).
- **write** — Can PUT (create/update) and DELETE secrets at matching paths.

Grant only `read` unless the agent must create or update secrets.

## Example: agent for one key

Policy: principal_type `agent`, principal_id `<agent_uuid>`, secret_path_pattern `api-keys/openai`, permissions `["read"]`. The agent can only read that one path.

## Example: agent for all keys, read-only

secret_path_pattern `api-keys/*`, permissions `["read"]`. The agent cannot write or delete.


---

## Securing Agent Access

---
title: Securing Agent Access
description: Best practices for token scoping, vault binding, and TTL configuration to minimize blast radius when an agent token is compromised.
sidebar_position: 2
---

# Securing Agent Access

Agents are 1claw's primary use case — AI systems that need credentials at runtime. Because agents operate autonomously, a leaked or over-privileged token can do more damage than a leaked human token. This guide covers the controls available to minimize that risk.

## The default is safe-by-default

When an agent has **no explicit scopes** and **no access policies**, its JWT contains an empty scope list. Empty scopes means zero access — the agent cannot read or write any secret until a human grants it a policy. You never need to worry about a misconfigured agent silently getting full vault access.

## 1. Vault binding

By default, an agent token is valid for any vault in the organization. **Vault binding** restricts the token to a specific set of vaults.

### When to use it

Always, unless the agent genuinely needs to access every vault. Most agents serve one purpose (e.g., "production secrets for the web app") and should be bound to the vault(s) that purpose requires.

### How it works

Set `vault_ids` on the agent (via the dashboard, SDK, or API):

```bash
# SDK
const agent = await client.agents.create({
    name: "web-backend",
    vault_ids: ["<vault-uuid>"],
});
```

The agent's JWT will include a `vault_ids` claim. Every vault endpoint checks this claim — if the vault is not in the list, the request is rejected with 403 before the policy engine is even consulted.

### Dashboard

On the agent detail page, the **Token Scoping** card has a "Vault Binding" section. Check the vaults this agent should access. Unchecked = all vaults (current behavior, preserved for backward compatibility).

## 2. Token TTL

The default agent token lifetime is 1 hour. For agents that run briefly (CI/CD, batch jobs, one-shot tasks), shorter tokens limit the window of exposure if a token leaks.

### Recommended TTLs

| Use case | Recommended TTL |
|---|---|
| CI/CD pipeline | 5 minutes (`300`) |
| Short-lived script or cron job | 15 minutes (`900`) |
| Long-running agent (chatbot, daemon) | 30–60 minutes (`1800`–`3600`) |

### How to set it

Set `token_ttl_seconds` on the agent:

```bash
# API
PUT /v1/agents/{agent_id}
{ "token_ttl_seconds": 300 }
```

Or in the dashboard: Agent detail → Token Scoping → Token TTL.

The SDK and MCP server automatically refresh tokens 60 seconds before expiry, so short TTLs don't cause downtime for long-running processes — the agent seamlessly gets a fresh token.

## 3. Scopes as an outer boundary

Agent JWTs contain a `scopes` field — a list of secret path glob patterns (e.g., `keys/**`, `prod/*`). Scopes are derived from the agent's access policies at token issuance time.

Scopes act as a **ceiling** on the token. Even if a policy later changes to grant broader access, the existing token can only access paths that match its scopes. The policy engine is still the source of truth for fine-grained checks, but scopes prevent a token from ever exceeding the access it was issued with.

### Scope + policy two-layer model

```
Request → Vault binding check → Scope glob check → Policy engine check → Owner bypass → Allow/Deny
```

1. **Vault binding**: Is this vault in the token's `vault_ids`? (If set.)
2. **Scope check**: Does any scope glob-match the secret path?
3. **Policy engine**: Does a matching policy grant the required permission?
4. **Owner bypass**: Is the caller the vault creator?

All four layers must pass. Scopes and vault binding are evaluated from the JWT alone (no DB query), making them fast and tamper-proof.

## 4. Policy conditions

Beyond scopes and vault binding, access policies support runtime conditions:

- **IP allowlist**: Only allow requests from specific IPs or CIDR ranges.
- **Time window**: Restrict access to certain hours and days of the week.

These conditions are evaluated by the policy engine on every request and can further narrow what a valid, in-scope token is allowed to do.

## 5. Crypto proxy and transaction guardrails

For agents that interact with blockchains, enable the **crypto transaction proxy** to prevent the agent from reading raw private keys. The agent submits transactions through a proxy that signs on its behalf.

Additionally, configure **transaction guardrails**:

- `tx_to_allowlist`: Permitted destination addresses.
- `tx_max_value_eth`: Maximum value per transaction.
- `tx_daily_limit_eth`: Rolling 24-hour spend cap.
- `tx_allowed_chains`: Restrict to specific chains.

See [Crypto Proxy guide](/docs/guides/crypto-proxy) for details.

## Checklist for production agents

- [ ] Vault binding configured (agent only accesses the vaults it needs)
- [ ] Token TTL set to the shortest practical value
- [ ] Access policies use narrow path patterns (not `**`)
- [ ] Scopes are derived from policies (don't manually set `["*"]`)
- [ ] IP allowlist set if the agent runs from known infrastructure
- [ ] Crypto proxy enabled if the agent handles blockchain operations
- [ ] Agent key rotated on a regular schedule


---

## Sharing Secrets

---
title: Sharing Secrets
description: Share secrets with teammates or external collaborators by email, even if they don't have an account yet.
sidebar_position: 4
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Sharing Secrets

1Claw supports sharing individual secrets with other users, agents, or external collaborators via email. Shares are time-limited, access-counted, and can be revoked at any time.

## Share types

| `recipient_type`   | Description                                                                     |
| ------------------ | ------------------------------------------------------------------------------- |
| `creator`          | Share back with the human who registered this agent (agents only, no ID needed) |
| `user`             | Direct share to an existing 1Claw user by ID                                    |
| `agent`            | Direct share to a registered agent by ID                                        |
| `external_email`   | Invite-by-email — the recipient doesn't need an account yet (humans only)       |
| `anyone_with_link` | Anyone with the share URL can access                                            |

## Create a share

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST https://api.1claw.xyz/v1/secrets/{secret_id}/share \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "recipient_type": "external_email",
    "email": "colleague@example.com",
    "expires_at": "2026-03-15T00:00:00Z",
    "max_access_count": 5
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
import { createClient } from "@1claw/sdk";

const client = createClient({
  baseUrl: "https://api.1claw.xyz",
  apiKey: process.env.ONECLAW_API_KEY,
});

const { data: share } = await client.sharing.create(secretId, {
  recipient_type: "external_email",
  email: "colleague@example.com",
  expires_at: "2026-03-15T00:00:00Z",
  max_access_count: 5,
});
```

</TabItem>
</Tabs>

**Response:**

```json
{
    "id": "uuid",
    "share_url": "https://api.1claw.xyz/v1/share/uuid",
    "recipient_type": "external_email",
    "recipient_email": "colleague@example.com",
    "expires_at": "2026-03-15T00:00:00Z",
    "max_access_count": 5
}
```

## Agent-to-human sharing (creator)

The simplest way for an agent to share a secret back with the human who owns it:

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST https://api.1claw.xyz/v1/secrets/{secret_id}/share \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "recipient_type": "creator",
    "expires_at": "2026-03-15T00:00:00Z",
    "max_access_count": 5
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: share } = await client.sharing.create(secretId, {
  recipient_type: "creator",
  expires_at: "2026-03-15T00:00:00Z",
  max_access_count: 5,
});
```

</TabItem>
</Tabs>

The backend resolves the agent's `created_by` field to identify the human. No user UUID or email needed. The human sees the share in their **Inbound** shares and accepts it.

**Via MCP:**

```
share_secret(secret_id: "...", recipient_type: "creator", expires_at: "2026-12-31T00:00:00Z")
```

## Invite-by-email flow

When a human shares with `recipient_type: "external_email"`:

1. A share record is created with the recipient's email.
2. The recipient receives an email notification with a link to sign in.
3. When the recipient signs up or logs in with that email, all pending shares are **automatically claimed** — they appear in the recipient's account.
4. The recipient can then access the shared secret through the API or dashboard.

Note: only humans can create email-based shares — agents are blocked from this type to prevent email spam.

## Access a share

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl https://api.1claw.xyz/v1/share/{share_id}
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: secret } = await client.sharing.access(shareId);
```

</TabItem>
</Tabs>

Returns the decrypted secret value if the share is still valid (not expired, under access limit).

## Revoke a share

Only the creator can revoke:

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X DELETE https://api.1claw.xyz/v1/share/{share_id} \
  -H "Authorization: Bearer $TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.sharing.revoke(shareId);
```

</TabItem>
</Tabs>

## Email notifications

When a share is created with `external_email`, the recipient receives an email. The share creator also receives a notification each time the shared secret is accessed.

See [Email Notifications](/docs/guides/email-notifications) for the full list of automated emails.

## Security considerations

- Shares respect the `max_access_count` — once exhausted, the link is dead.
- Shares expire at `expires_at` — past that datetime, access is denied.
- Share creators are notified on each access.
- Revoked shares return 404 immediately.
- Optional: add a `passphrase` or `ip_allowlist` to the share for additional protection.


---

## Troubleshooting

---
title: Troubleshooting
description: Common issues when using the API, SDK, CLI, or MCP — and how to fix them.
sidebar_position: 12
---

# Troubleshooting

Quick fixes for issues you might hit as a user of the API, SDK, CLI, or MCP.

## "Can't reach the API" / connection errors

- **Base URL** — Use `https://api.1claw.xyz` for production. The dashboard at 1claw.xyz proxies `/api/*` to the same API, so from a browser you may use relative `/api/v1/...` when on the same origin.
- **CLI / SDK** — Ensure your client is configured with the correct base URL. The SDK and CLI default to the production API when not set.
- **MCP** — For hosted MCP, use `https://mcp.1claw.xyz/mcp`. For local stdio, `ONECLAW_BASE_URL` defaults to `https://api.1claw.xyz`; override only if you use a different API host.

## 401 Unauthorized

- **Missing or invalid token** — Include `Authorization: Bearer <token>`. For agents, get a fresh JWT via `POST /v1/auth/agent-token` (tokens expire; the MCP server refreshes automatically when using agent ID + API key).
- **Revoked key** — If you rotated an agent key or revoked a personal API key, use the new key or log in again.
- **Wrong credentials** — For `POST /v1/auth/token`, use `email` and `password` (not username). Check for typos or wrong environment variable.

## 402 Payment Required

- Your request count has exceeded your tier’s monthly limit and the API is asking for payment (x402 or prepaid credits).
- **What to do:** Upgrade your plan, add prepaid credits, or complete the x402 payment for this request. In the dashboard, go to [Settings → Billing](https://1claw.xyz/settings/billing). See [Billing & Usage](/docs/guides/billing-and-usage).

## 403 Forbidden

- **No permission for this resource** — Your token is valid but you don’t have a policy that allows this action on this vault/path. Add or update a policy (dashboard: Vault → Policies), or use a vault you own or have been granted access to.
- **Resource limit exceeded** — You’ve hit your subscription’s limit for vaults, secrets, or agents. The response body has `type: "resource_limit_exceeded"` and a message like "Vault limit reached (3/3 on free tier)". Upgrade your plan or delete unused resources. See [Billing & Usage](/docs/guides/billing-and-usage).
- **Crypto proxy** — You’re calling a transaction endpoint (e.g. submit or simulate) but your agent doesn’t have `crypto_proxy_enabled`. Enable it in the dashboard (Agent → edit) or via the API.
- **IP denied** — Your org has IP allow/block rules and your current IP is not allowed. Check Security → IP rules in the dashboard.

## 404 Not Found

- **Vault or secret path** — Check the vault ID and path. Paths are case-sensitive and must match exactly. Use list endpoints (`GET /v1/vaults`, `GET /v1/vaults/:id/secrets`) to confirm IDs and paths.
- **Agent ID** — When calling agent or transaction endpoints, ensure the agent ID is correct and the agent belongs to your org.

## 410 Gone

- The secret has expired (`expires_at` passed), been soft-deleted, or exceeded `max_access_count`. Store a new version of the secret or use a different path.

## 429 Too Many Requests

- You’ve hit the global rate limit. Wait and retry; the response may include a `Retry-After` header. Share creation is also limited to 10 per minute per org.

## MCP: "Access denied" or 403 on get_secret

- The agent must have a **policy** that grants read access to that vault and path. Create a policy in the dashboard (Vault → Policies) with the agent as principal and a path pattern that matches the secret (e.g. `**` for all paths). See [Give an agent access](/docs/guides/give-agent-access).

## CLI: Device login not completing

- Approve the device code in the dashboard: go to the CLI verification page (linked from the CLI output) and sign in, then approve. Ensure you’re using the same account as the one that started the device flow.

---

For a full list of error codes and response shapes, see [Error codes](/docs/reference/error-codes). For how the API processes requests (auth, rate limit, billing), see [Request pipeline](/docs/reference/request-pipeline).


---

## Deactivate agent / Rotate key

---
title: Deactivate agent / Rotate key
description: Deactivate an agent with DELETE /v1/agents/{agent_id}; get a new API key with POST /v1/agents/{agent_id}/rotate-key.
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Deactivate agent / Rotate key

## Deactivate an agent

**Endpoint:** `DELETE /v1/agents/:agent_id`  
**Authentication:** Bearer JWT

Marks the agent as inactive. The agent can no longer exchange its API key for a token; existing JWTs may still be valid until expiry.

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X DELETE "https://api.1claw.xyz/v1/agents/ec7e0226-30f0-4dda-b169-f060a3502603" \
  -H "Authorization: Bearer <token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.agents.delete(agentId);
```

</TabItem>
</Tabs>

**Response:** 204 No Content.

---

## Rotate agent key

**Endpoint:** `POST /v1/agents/:agent_id/rotate-key`  
**Authentication:** Bearer JWT

Generates a **new** API key for the agent. The old key stops working. Response includes the new key (shown only once).

**Example request:**

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/agents/ec7e0226-30f0-4dda-b169-f060a3502603/rotate-key" \
  -H "Authorization: Bearer <token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data } = await client.agents.rotateKey(agentId);
console.log(data.api_key); // Store new key
```

</TabItem>
</Tabs>

**Example response (200):** Same shape as create agent: `{ "agent": { ... }, "api_key": "ocv_..." }`. Store the new `api_key` and update the agent's config.

---

## Get or update agent

- **GET /v1/agents/:agent_id** — Returns single agent metadata (no API key).
- **PATCH /v1/agents/:agent_id** — Update name, description, scopes, is_active, expires_at.


---

## List agents

---
title: List agents
description: List all agents in your org with GET /v1/agents.
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# List agents

**Endpoint:** `GET /v1/agents`  
**Authentication:** Bearer JWT

Returns all agents in the caller's organization. API keys are never returned; only metadata.

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s "https://api.1claw.xyz/v1/agents" \
  -H "Authorization: Bearer <token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data } = await client.agents.list();
for (const a of data.agents) {
  console.log(a.name, a.id, a.is_active);
}
```

</TabItem>
</Tabs>

## Example response (200)

```json
{
  "agents": [
    {
      "id": "ec7e0226-30f0-4dda-b169-f060a3502603",
      "name": "CI Agent",
      "description": "GitHub Actions deploy",
      "auth_method": "api_key",
      "scopes": ["vaults:read"],
      "is_active": true,
      "created_at": "2026-02-18T12:00:00Z",
      "expires_at": null,
      "last_active_at": "2026-02-18T14:00:00Z"
    }
  ]
}
```


---

## Register an agent

---
title: Register an agent
description: Create an agent identity and receive an API key using POST /v1/agents; the key is shown only once.
sidebar_position: 0
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Register an agent

**Endpoint:** `POST /v1/agents`  
**Authentication:** Bearer JWT (human)

Creates a new agent identity and returns an **API key** (`ocv_...`). The key is returned only on create (and on rotate); store it securely for the agent to use with `POST /v1/auth/agent-token`.

In addition to the API key, each agent automatically receives:

- **Ed25519 signing keypair** — public key on the agent record (`ssh_public_key`), private key in the org's `__agent-keys` vault.
- **P-256 ECDH keypair** — public key on the agent record (`ecdh_public_key`), private key in `__agent-keys`.

See [Agent keys](/docs/security/agent-keys) for details on key formats and how to access private keys.

## Request body

| Field                | Type    | Required | Description                                                                                                                                                                                                                                                     |
| -------------------- | ------- | -------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| name                 | string  | ✅       | Display name for the agent                                                                                                                                                                                                                                      |
| description          | string  | ❌       | Optional description                                                                                                                                                                                                                                            |
| auth_method          | string  | ❌       | Default `api_key`                                                                                                                                                                                                                                               |
| scopes               | array   | ❌       | Optional scope strings                                                                                                                                                                                                                                          |
| expires_at           | string  | ❌       | ISO 8601; agent token exchange fails after this                                                                                                                                                                                                                 |
| crypto_proxy_enabled | boolean | ❌       | Default `false`. When `true`, the agent **must** use the transaction proxy to broadcast crypto transactions and is **blocked** from reading `private_key` and `ssh_key` type secrets directly. See [Crypto Transaction Proxy](#crypto-transaction-proxy) below. |

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/agents" \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "DeFi Bot",
    "description": "Automated trading agent",
    "crypto_proxy_enabled": true,
    "scopes": ["vaults:read"]
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data } = await client.agents.create({
  name: "DeFi Bot",
  description: "Automated trading agent",
  crypto_proxy_enabled: true,
  scopes: ["vaults:read"],
});
console.log(data.agent.id, data.api_key); // Store api_key securely
```

</TabItem>
</Tabs>

## Example response (201)

```json
{
    "agent": {
        "id": "ec7e0226-30f0-4dda-b169-f060a3502603",
        "name": "DeFi Bot",
        "description": "Automated trading agent",
        "auth_method": "api_key",
        "scopes": ["vaults:read"],
        "is_active": true,
        "crypto_proxy_enabled": true,
        "ssh_public_key": "m+Z6jV5W86WMTV27cpk9QGXIo+fP1OX88dHxdj6DHUI=",
        "ecdh_public_key": "BDq8k3Lw...base64...65bytes...",
        "created_at": "2026-02-18T12:00:00Z"
    },
    "api_key": "ocv_W3_eYj0BSdTjChKwCKRYuZJacmmhVn4ozWIxHV-zlEs"
}
```

Store the `api_key` securely; it cannot be retrieved again. Use [Deactivate agent / Rotate key](/docs/human-api/agents/deactivate-agent#rotate-agent-key) to get a new key if needed.

## Crypto Transaction Proxy

When `crypto_proxy_enabled` is set to `true`:

1. **Transaction proxy access** — The agent can call `POST /v1/agents/:id/transactions` to submit transactions that the signing proxy will broadcast using keys stored in the vault.

2. **Private key reads blocked** — The agent is **blocked** from reading secrets of type `private_key` or `ssh_key` through the normal `GET /v1/vaults/:vault_id/secrets/:path` endpoint. Any attempt returns `403 Forbidden`.

3. **Other secrets unaffected** — The agent can still read `api_key`, `password`, `certificate`, `env_bundle`, and other secret types normally (subject to policies).

This enforcement means the agent can never exfiltrate raw signing keys — it can only request that the server sign and broadcast transactions on its behalf.

### When to enable

- The agent needs to initiate financial transactions (swaps, transfers, contract calls)
- You want to prevent the agent from ever seeing the raw private key
- You want a full audit trail of every transaction the agent submits

### When to leave disabled

- The agent only needs to read API keys, passwords, or config secrets
- The agent doesn't interact with blockchain transactions


---

## Authentication

---
title: Authentication
description: Get a JWT for the Human API using email/password, Google id_token, or a personal API key (Bearer token).
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Authentication

The Human API expects a **JWT** in the `Authorization` header:

```http
Authorization: Bearer <access_token>
```

You can obtain an access token in three ways: email/password, Google OAuth, or a personal API key.

---

## Email and password

**Endpoint:** `POST /v1/auth/token`  
**Request body:**

| Field     | Type   | Required | Description |
|----------|--------|----------|-------------|
| email    | string | ✅       | User email  |
| password | string | ✅       | Password    |

**Example:**

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST https://api.1claw.xyz/v1/auth/token \
  -H "Content-Type: application/json" \
  -d '{"email":"you@example.com","password":"your-password"}'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.auth.login({
  email: "you@example.com",
  password: "your-password",
});
```

</TabItem>
</Tabs>

**Response (200):**

```json
{
  "access_token": "eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9...",
  "token_type": "Bearer",
  "expires_in": 900
}
```

`expires_in` is in seconds (e.g. 900 = 15 minutes). On 401 you get a problem-details JSON body.

---

## Google OAuth

**Endpoint:** `POST /v1/auth/google`  
**Request body:**

| Field     | Type   | Required | Description                    |
|----------|--------|----------|--------------------------------|
| id_token | string | ✅       | Google ID token from OAuth    |

**Example:**

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST https://api.1claw.xyz/v1/auth/google \
  -H "Content-Type: application/json" \
  -d '{"id_token":"<google-id-token>"}'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.auth.google({
  id_token: "<google-id-token>",
});
```

</TabItem>
</Tabs>

**Response (200):** Same as email/password (`access_token`, `token_type`, `expires_in`).

---

## Personal API key

If you have a **personal API key** (e.g. `1ck_...` from the dashboard or `POST /v1/auth/api-keys`), exchange it for a JWT:

**Endpoint:** `POST /v1/auth/api-key-token`  
**Request body:**

| Field    | Type   | Required | Description      |
|----------|--------|----------|------------------|
| api_key  | string | ✅       | Your API key     |

**Example:**

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST https://api.1claw.xyz/v1/auth/api-key-token \
  -H "Content-Type: application/json" \
  -d '{"api_key":"1ck_..."}'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const client = createClient({
  baseUrl: "https://api.1claw.xyz",
  apiKey: "1ck_...",
});
```

</TabItem>
</Tabs>

**Response (200):** Same shape as above.

---

## Revoke token

**Endpoint:** `DELETE /v1/auth/token`  
**Headers:** `Authorization: Bearer <token>`

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X DELETE https://api.1claw.xyz/v1/auth/token \
  -H "Authorization: Bearer <token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.auth.logout();
```

</TabItem>
</Tabs>

Returns **204 No Content** on success. Useful to invalidate the current token (e.g. on logout).

---

## Change password

**Endpoint:** `POST /v1/auth/change-password`  
**Headers:** `Authorization: Bearer <token>`  
**Request body:**

| Field            | Type   | Required | Description   |
|------------------|--------|----------|---------------|
| current_password | string | ✅       | Current pwd   |
| new_password     | string | ✅       | New password  |

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST https://api.1claw.xyz/v1/auth/change-password \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{"current_password":"...","new_password":"..."}'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.auth.changePassword({
  current_password: "...",
  new_password: "...",
});
```

</TabItem>
</Tabs>

**Response (200):** `{ "message": "Password changed successfully" }`

---

## Error responses

| Status | Meaning                    |
|--------|----------------------------|
| 401    | Invalid credentials/token  |
| 400    | Bad request (e.g. missing field) |

All error bodies use the standard problem-details format (`type`, `title`, `status`, `detail`).


---

## Human API errors

---
title: Human API errors
description: The Human API returns RFC 7807 problem-details and uses standard HTTP status codes for auth, validation, and server errors.
sidebar_position: 99
---

# Human API errors

All error responses use **RFC 7807** problem details: a JSON body with `type`, `title`, `status`, and `detail`. The API does not expose internal stack traces or key material.

## HTTP status codes

| Code | Meaning |
|------|---------|
| 400 | Bad Request — Invalid path, body, or parameters |
| 401 | Unauthorized — Missing or invalid Authorization header / token |
| 403 | Forbidden — Valid token but insufficient permission (or resource limit reached) |
| 404 | Not Found — Vault, secret, policy, or agent not found |
| 409 | Conflict — e.g. name already in use (if applicable) |
| 410 | Gone — Secret expired, deleted, or over max_access_count |
| 429 | Too Many Requests — Rate limited |
| 500 | Internal Server Error — Server-side failure (detail is generic) |

## Response body

```json
{
  "type": "about:blank",
  "title": "Unauthorized",
  "status": 401,
  "detail": "Invalid or expired token"
}
```

`detail` may vary; it is safe to show to the client. For 500 errors the detail is generic (e.g. "An unexpected error occurred") to avoid leaking internals.

## Common cases

- **401** — Omit `Authorization`, invalid JWT, or expired JWT. Fix: obtain a new token.
- **403** — Policy does not grant the requested permission, or not the vault owner. Fix: add/update policy or use an allowed principal. If `type` is `"resource_limit_exceeded"`, you've hit a tier limit for vaults, secrets, or agents — upgrade your plan at `/settings/billing`.
- **404** — Wrong vault_id or path, or resource was deleted. Fix: check IDs and path.
- **410** — Secret is expired, soft-deleted, or over max_access_count. Fix: create a new version or new secret.

See [Error codes reference](/docs/reference/error-codes) for a full list.


---

## Create a policy (grant)

---
title: Create a policy (grant)
description: Grant a principal read/write/delete access to secret paths in a vault using POST /v1/vaults/{vault_id}/policies.
sidebar_position: 0
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Create a policy (grant)

Policies link a **principal** (user or agent) to **secret path patterns** with a set of **permissions** (e.g. read, write, delete). Path matching uses globs: `*` for one segment, `**` for any depth.

In the **dashboard** at [1claw.xyz](https://1claw.xyz), use **Vaults → [vault] → Policies → Create Policy**. You can select the target vault from a dropdown and, for agents, pick from your registered agents or enter a custom agent ID.

**Endpoint:** `POST /v1/vaults/:vault_id/policies`  
**Authentication:** Bearer JWT (vault access)

## Request body

| Field               | Type   | Required | Description                                      |
| ------------------- | ------ | -------- | ------------------------------------------------ |
| secret_path_pattern | string | ✅       | Glob pattern (e.g. `**`, `prod/*`, `api-keys/*`) |
| principal_type      | string | ✅       | `user` or `agent`                                |
| principal_id        | string | ✅       | UUID of the user or agent                        |
| permissions         | array  | ✅       | e.g. `["read"]`, `["read","write"]`              |
| conditions          | object | ❌       | Optional (e.g. ip_allowlist, time_window)        |
| expires_at          | string | ❌       | ISO 8601; policy stops applying after this time  |

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/vaults/ae370174-9aee-4b02-ba7c-d1519930c709/policies" \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{
    "secret_path_pattern": "**",
    "principal_type": "agent",
    "principal_id": "ec7e0226-30f0-4dda-b169-f060a3502603",
    "permissions": ["read"]
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.access.grantAgent({
  vault_id: vaultId,
  secret_path_pattern: "**",
  principal_id: agentId,
  permissions: ["read"],
});
```

</TabItem>
</Tabs>

## Example response (201)

```json
{
    "id": "897b37da-a265-4bd4-818b-e716eeff3de3",
    "vault_id": "ae370174-9aee-4b02-ba7c-d1519930c709",
    "secret_path_pattern": "**",
    "principal_type": "agent",
    "principal_id": "ec7e0226-30f0-4dda-b169-f060a3502603",
    "permissions": ["read"],
    "conditions": {},
    "created_by": "2a57eb5e-caac-4e34-9685-b94c37458eb1",
    "created_at": "2026-02-18T12:00:00Z"
}
```

## Error responses

| Code | Meaning                                      |
| ---- | -------------------------------------------- |
| 400  | Validation error (e.g. empty permissions)    |
| 401  | Invalid or missing token                     |
| 403  | Not allowed to create policies on this vault |
| 404  | Vault not found                              |


---

## List policies (grants)

---
title: List policies (grants)
description: List all policies for a vault with GET /v1/vaults/{vault_id}/policies.
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# List policies (grants)

**Endpoint:** `GET /v1/vaults/:vault_id/policies`  
**Authentication:** Bearer JWT

Returns all policies (grants) for the given vault.

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s "https://api.1claw.xyz/v1/vaults/ae370174-9aee-4b02-ba7c-d1519930c709/policies" \
  -H "Authorization: Bearer <token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data } = await client.access.listGrants(vaultId);
for (const p of data.policies) {
  console.log(p.id, p.principal_type, p.permissions);
}
```

</TabItem>
</Tabs>

## Example response (200)

```json
{
    "policies": [
        {
            "id": "897b37da-a265-4bd4-818b-e716eeff3de3",
            "vault_id": "ae370174-9aee-4b02-ba7c-d1519930c709",
            "secret_path_pattern": "**",
            "principal_type": "agent",
            "principal_id": "ec7e0226-30f0-4dda-b169-f060a3502603",
            "permissions": ["read"],
            "conditions": {},
            "created_by": "2a57eb5e-caac-4e34-9685-b94c37458eb1",
            "created_at": "2026-02-18T12:00:00Z"
        }
    ]
}
```

## Update a policy

**Endpoint:** `PUT /v1/vaults/:vault_id/policies/:policy_id`  
**Body:** `permissions` (array), optional `conditions` (object), optional `expires_at` (ISO 8601). Only these fields can be updated; path pattern and principal are fixed after creation.

In the **dashboard**, open **Vaults → [vault] → Policies** and click the pencil (edit) icon on a policy to change permissions, conditions, or expiry. Use the trash icon to delete a policy.


---

## Revoke a policy (grant)

---
title: Revoke a policy (grant)
description: Delete a policy with DELETE /v1/vaults/{vault_id}/policies/{policy_id}; the principal immediately loses the granted access.
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Revoke a policy (grant)

**Endpoint:** `DELETE /v1/vaults/:vault_id/policies/:policy_id`  
**Authentication:** Bearer JWT

Removes the policy. The principal (user or agent) immediately loses the permissions that policy granted.

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X DELETE "https://api.1claw.xyz/v1/vaults/$VAULT_ID/policies/897b37da-a265-4bd4-818b-e716eeff3de3" \
  -H "Authorization: Bearer <token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.access.revoke(vaultId, policyId);
```

</TabItem>
</Tabs>

## Response

**204 No Content** — Success.

## Error responses

| Code | Meaning |
|------|---------|
| 401 | Invalid or missing token |
| 403 | Not allowed |
| 404 | Vault or policy not found |


---

## Human API overview

---
title: Human API overview
description: The Human API is the full REST API for vaults, secrets, policies, agents, audit, and billing; authenticate with email/password, Google, or personal API key.
sidebar_position: 0
---

# Human API overview

The **Human API** is the full set of REST endpoints used by secret owners: create and manage vaults, store and retrieve secrets, define policies (grants), register and manage agents, view audit logs, and manage billing/usage. You use it with a **JWT** obtained via email/password, Google OAuth, or a personal API key.

## Base URL

- **Production:** `https://api.1claw.xyz` (or your Cloud Run URL, e.g. `https://oneclaw-vault-XXXX.run.app`)
- **Dashboard proxy:** The app at [1claw.xyz](https://1claw.xyz) proxies `/api/v1/*` to the same API, so from the browser the base is effectively `https://1claw.xyz/api`.

All endpoints are under the `/v1` prefix.

## Authentication

Every request (except health and public auth endpoints) must include:

```http
Authorization: Bearer <access_token>
```

Ways to get an access token:

| Method           | Endpoint                      | Request body                               |
| ---------------- | ----------------------------- | ------------------------------------------ |
| **Signup**       | `POST /v1/auth/signup`        | `{ "email", "password", "display_name?" }` |
| Email + password | `POST /v1/auth/token`         | `{ "email", "password" }`                  |
| Google OAuth     | `POST /v1/auth/google`        | `{ "id_token" }`                           |
| Personal API key | `POST /v1/auth/api-key-token` | `{ "api_key" }` (e.g. `1ck_...`)           |

See [Authentication](/docs/human-api/authentication) for details and response shape.

## Main areas

| Area         | Endpoints                                                                           | Purpose                                                                |
| ------------ | ----------------------------------------------------------------------------------- | ---------------------------------------------------------------------- |
| **Vaults**   | POST/GET /v1/vaults, GET/DELETE /v1/vaults/:vault_id                                | Create, list, get, delete vaults                                       |
| **Secrets**  | PUT/GET/DELETE /v1/vaults/:vault_id/secrets/:path, GET /v1/vaults/:vault_id/secrets | Store, read, list, delete secrets                                      |
| **Policies** | POST/GET /v1/vaults/:vault_id/policies, PUT/DELETE .../policies/:policy_id          | Grant/revoke access to principals                                      |
| **Agents**   | POST/GET /v1/agents, GET/PATCH/DELETE /v1/agents/:agent_id, POST .../rotate-key     | Register agents, rotate keys                                           |
| **Sharing**  | POST /v1/secrets/:secret_id/share, GET/DELETE /v1/share/:share_id                   | Share secrets by email or link ([guide](/docs/guides/sharing-secrets)) |
| **Audit**    | GET /v1/audit/events                                                                | Query audit events                                                     |
| **Billing**  | GET /v1/billing/usage, GET /v1/billing/history                                      | Usage and history                                                      |
| **Org**      | GET /v1/org/members, PATCH/DELETE /v1/org/members/:user_id                          | Team members                                                           |
| **API keys** | POST/GET /v1/auth/api-keys, DELETE /v1/auth/api-keys/:key_id                        | Personal API keys                                                      |

## Response and errors

- Success responses return JSON with the documented shape (or 204 No Content for deletes).
- Errors use **RFC 7807**-style JSON: `type`, `title`, `status`, `detail`. See [Error codes](/docs/reference/error-codes) and [Human API errors](/docs/human-api/errors).

## Next

- [Authentication](/docs/human-api/authentication) — All ways to get a JWT.
- [Secrets: create](/docs/human-api/secrets/create) — PUT a secret with full request/response.


---

## Create or update a secret

---
title: Create or update a secret
description: Store a new secret or new version at a path in a vault using PUT /v1/vaults/{vault_id}/secrets/{path}; authentication is Bearer JWT.
sidebar_position: 0
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Create or update a secret

Store a secret in a vault at a given **path**. If the path already exists, this creates a **new version**. Path is slash-separated (e.g. `passwords/one`, `api-keys/stripe`). Paths must be alphanumeric with hyphens, underscores, and slashes; no leading or trailing slashes.

**Endpoint:** `PUT /v1/vaults/:vault_id/secrets/:path`  
**Authentication:** Human API Key (Bearer JWT)

## Path

- `vault_id` — UUID of the vault.
- `path` — Secret path (e.g. `api-keys/openai`). Can contain multiple segments; the API uses a wildcard `{*path}` so use the full path as in the URL.

## Request body

| Field           | Type   | Required | Description |
|----------------|--------|----------|-------------|
| type           | string | ✅       | One of: `password`, `api_key`, `private_key`, `certificate`, `file`, `note`, `ssh_key`, `env_bundle` |
| value          | string | ✅       | The secret value (plaintext) to store |
| metadata       | object | ❌       | Optional JSON (e.g. tags, description) |
| expires_at     | string | ❌       | ISO 8601 datetime; secret unavailable after this time |
| rotation_policy| object | ❌       | Reserved for future use |
| max_access_count | number | ❌    | After this many reads, secret returns 410 Gone |

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X PUT "https://api.1claw.xyz/v1/vaults/ae370174-9aee-4b02-ba7c-d1519930c709/secrets/api-keys/openai" \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "api_key",
    "value": "sk-proj-...",
    "metadata": {"tags": ["openai", "production"], "description": "OpenAI production key"},
    "expires_at": "2026-12-31T23:59:59Z"
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.secrets.set(vaultId, "api-keys/openai", "sk-proj-...", {
  type: "api_key",
  metadata: {
    tags: ["openai", "production"],
    description: "OpenAI production key",
  },
  expires_at: "2026-12-31T23:59:59Z",
});
```

</TabItem>
</Tabs>

## Example response (201 Created)

```json
{
  "id": "599dd304-920c-4459-ae07-d62a3515381b",
  "path": "api-keys/openai",
  "type": "api_key",
  "version": 1,
  "metadata": {"tags": ["openai", "production"], "description": "OpenAI production key"},
  "created_at": "2026-02-18T12:00:00Z",
  "expires_at": "2026-12-31T23:59:59Z"
}
```

If the path already had a version, the new version number is incremented and you still get **201**.

> ⚠️ The secret `value` is **never** returned after creation. Only metadata is returned.

## Error responses

| Code | Meaning |
|------|---------|
| 400 | Invalid path format or request body |
| 401 | Invalid or missing token |
| 403 | No write permission for this path (policy or vault owner) |
| 404 | Vault not found |
| 500 | Internal error (e.g. HSM or DB) |

All error bodies use RFC 7807 problem-details (`type`, `title`, `status`, `detail`).


---

## Delete a secret

---
title: Delete a secret
description: Soft-delete a secret at a path using DELETE /v1/vaults/{vault_id}/secrets/{path}; subsequent reads return 410 Gone.
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Delete a secret

Soft-delete a secret at a path. All versions of that path are marked deleted; they are not returned in list or get, and GET returns **410 Gone**.

**Endpoint:** `DELETE /v1/vaults/:vault_id/secrets/:path`  
**Authentication:** Bearer JWT (write permission or vault owner)

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X DELETE "https://api.1claw.xyz/v1/vaults/ae370174-9aee-4b02-ba7c-d1519930c709/secrets/api-keys/old-key" \
  -H "Authorization: Bearer <token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.secrets.delete(vaultId, "api-keys/old-key");
```

</TabItem>
</Tabs>

## Response

**204 No Content** — Success. No body.

## Error responses

| Code | Meaning |
|------|---------|
| 401 | Invalid or missing token |
| 403 | No delete/write permission |
| 404 | Vault not found |

After deletion, `GET .../secrets/:path` for that path returns **410 Gone**.


---

## Read a secret

---
title: Read a secret
description: Retrieve the decrypted value and metadata of a secret by vault ID and path using GET /v1/vaults/{vault_id}/secrets/{path}.
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Read a secret

Retrieve the **decrypted value** and metadata of a secret. Requires read permission (policy or vault owner).

**Endpoint:** `GET /v1/vaults/:vault_id/secrets/:path`  
**Authentication:** Bearer JWT (human or agent)

## Path

- `vault_id` — UUID of the vault.
- `path` — Secret path (e.g. `api-keys/openai`). Returns the **latest** version unless you use a versioned endpoint (if available).

## Example request

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s "https://api.1claw.xyz/v1/vaults/ae370174-9aee-4b02-ba7c-d1519930c709/secrets/api-keys/openai" \
  -H "Authorization: Bearer <token>"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: secret } = await client.secrets.get(vaultId, "api-keys/openai");
console.log(secret.value);
```

</TabItem>
</Tabs>

## Example response (200)

```json
{
  "id": "599dd304-920c-4459-ae07-d62a3515381b",
  "path": "api-keys/openai",
  "type": "api_key",
  "value": "sk-proj-...",
  "version": 1,
  "metadata": {"tags": ["openai", "production"]},
  "created_by": "user:2a57eb5e-caac-4e34-9685-b94c37458eb1",
  "created_at": "2026-02-18T12:00:00Z",
  "expires_at": "2026-12-31T23:59:59Z"
}
```

Treat the `value` field as highly sensitive; do not log or persist it unnecessarily.

## Error responses

| Code | Meaning |
|------|---------|
| 401 | Invalid or missing token |
| 403 | No read permission |
| 404 | Vault or secret not found |
| 410 | Secret expired, deleted, or over max_access_count (Gone) |


---

## Rotate a secret

---
title: Rotate a secret
description: The rotate endpoint may return 400 not yet implemented; for now create a new version with PUT to the same path.
sidebar_position: 4
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rotate a secret

**Endpoint:** `POST /v1/vaults/:vault_id/secrets/:path/rotate`  
**Authentication:** Bearer JWT

<!-- TODO: verify --> The vault implementation may return **400 Bad Request** with a message that secret rotation is not yet implemented. When that is the case, "rotation" is achieved by creating a **new version** of the secret:

1. Generate a new value (e.g. new API key from the provider).
2. **PUT** to the same path with the new value (see [Create](/docs/human-api/secrets/create) / [Update](/docs/human-api/secrets/update)).
3. Optionally revoke or expire the old key at the provider.

Once rotation is implemented, this endpoint may accept an optional body (e.g. `new_value` or trigger provider rotation) and return the new secret metadata. Check the [API reference](/docs/reference/api-reference) or OpenAPI spec for the current contract.

## Example (when implemented)

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai/rotate" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"new_value":"sk-proj-..."}'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.secrets.set(vaultId, "api-keys/openai", "sk-proj-NEW...", {
  type: "api_key",
}); // Creates a new version
```

</TabItem>
</Tabs>

## Current behavior

If the server responds with **400** and a message like "Secret rotation not yet implemented", use **PUT** to the same path with the new value instead.


---

## Update a secret (new version)

---
title: Update a secret (new version)
description: Creating a new version of a secret is done by PUT to the same path; the API creates a new version and returns 201 with updated metadata.
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Update a secret (new version)

In 1claw, there is no separate "update" endpoint. To **update** a secret you **PUT** to the same vault and path with a new body. That creates a **new version** (version 2, 3, …). The previous version remains stored but the default "latest" read returns the newest version.

**Endpoint:** `PUT /v1/vaults/:vault_id/secrets/:path`  
**Authentication:** Bearer JWT

Same request body as [Create a secret](/docs/human-api/secrets/create): `type`, `value`, and optional `metadata`, `expires_at`, `rotation_policy`, `max_access_count`.

## Example

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X PUT "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"api_key","value":"sk-proj-NEW-KEY..."}'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.secrets.set(vaultId, "api-keys/openai", "sk-proj-NEW-KEY...", {
  type: "api_key",
});
```

</TabItem>
</Tabs>

**Response (201):** Same shape as create; `version` will be 2 (or next). The secret value is never returned.

To read a **specific** version, use the versioned endpoint if your deployment supports it (e.g. `GET .../secrets/:path/versions/:v`). Otherwise only the latest is available via `GET .../secrets/:path`.

## Related

- [Create a secret](/docs/human-api/secrets/create) — Full request/response.
- [Rotate a secret](/docs/human-api/secrets/rotate) — Rotation endpoint (may return 400 "not yet implemented").


---

## Introduction

---
title: Introduction
description: 1claw is a cloud HSM secrets manager that lets humans grant AI agents scoped, audited, revocable access to secrets without exposing raw credentials.
sidebar_position: 0
---

# Introduction

1claw is a **cloud-hosted Hardware Security Module (HSM) secrets manager** for humans and AI agents. It lets you store API keys, tokens, and other credentials in a vault encrypted by keys that never leave the HSM. You control which agents can access which secrets, with what permissions, and for how long — and agents fetch secrets at runtime instead of holding them in context or environment.

## The problem 1claw solves

AI agents often need secrets (API keys, tokens, DB credentials) to call external services. If you paste a secret into a chat or put it in an agent's environment, it can be logged, leaked, or retained. 1claw keeps secrets in an HSM-backed vault and gives agents **scoped, audited, revocable** access: the agent authenticates to 1claw and requests a secret by path; 1claw returns the decrypted value only if the agent is allowed. The agent never stores the secret; you can revoke access or rotate the secret at any time.

## Architecture

```
┌─────────────┐     ┌─────────────┐     ┌─────────────┐
│  Dashboard  │────▶│  Vault API  │◀────│  MCP Server │
│  (Next.js)  │     │  (Rust)     │     │  (Node.js)  │
│  1claw.xyz  │     │ api.1claw.xyz│    │mcp.1claw.xyz│
└─────────────┘     └──────┬──────┘     └─────────────┘
                           │
                ┌──────────┼──────────┐
                ▼          ▼          ▼
          ┌──────────┐ ┌──────┐ ┌──────────┐
          │ Supabase │ │ KMS  │ │  Audit   │
          │ Postgres │ │(keys)│ │  (log)   │
          └──────────┘ └──────┘ └──────────┘
```

- **Dashboard** — The web UI at [1claw.xyz](https://1claw.xyz) where humans manage vaults, secrets, agents, and policies. After you sign in, the left sidebar gives you: **Dashboard**, **Vaults**, **Agents**, **Sharing**, **Audit Log**, **Security**, **API Keys**, **Billing**, and **Team**.
- **Vault API** — The Rust backend that handles authentication, envelope encryption, policy enforcement, and all CRUD operations. Both the dashboard and MCP server talk to it.
- **MCP Server** — A [Model Context Protocol](https://modelcontextprotocol.io) server that gives AI agents (Claude, Cursor, GPT) just-in-time access to vault secrets. Available hosted at `mcp.1claw.xyz` or as a local stdio process.

### How humans and agents interact

- **Humans** log in (email/password or Google) or use a personal API key (`1ck_`). They create vaults, store secrets at paths, register agents, and attach policies that grant agents (or users) read/write access to path patterns.
- **Agents** authenticate with an agent API key (`ocv_`) via `POST /v1/auth/agent-token` to get a short-lived JWT, then call the same API to list secrets and fetch secret values by path. Access is enforced by policies; all access is audited.

## Two APIs, one base URL

The same REST API serves both personas:

| Persona   | Auth                                                      | Typical operations                                                                       |
| --------- | --------------------------------------------------------- | ---------------------------------------------------------------------------------------- |
| **Human** | Email/password or Google → JWT; or personal API key → JWT | Create vaults, PUT/GET/DELETE secrets, create/list policies, register agents, audit logs |
| **Agent** | Agent API key → JWT via `/v1/auth/agent-token`            | GET secret by path, list secrets in a vault (subject to policies)                        |

Base URL: `https://api.1claw.xyz` (or your Cloud Run URL). The dashboard at [1claw.xyz](https://1claw.xyz) proxies `/api/v1/*` to the same API.

## What you'll find in these docs

- **Concepts** — Vaults, secrets, policies, agents, HSM architecture, and [parts of 1claw](/docs/concepts/parts-of-1claw) (API, Dashboard, MCP, CLI, SDK).
- **Quickstart** — Get a token (human or agent) and read/write a secret.
- **Human API** — Every endpoint for vaults, secrets, policies, agents, billing, audit.
- **Agent API** — Auth and fetching secrets; same endpoints with agent JWT.
- **MCP Server** — Give AI agents (Claude, Cursor, GPT) direct access to secrets via the Model Context Protocol. Hosted at `mcp.1claw.xyz` or run locally.
- **SDKs** — TypeScript/JavaScript and curl examples.
- **Guides** — Give an agent access, rotate secrets, revoke access, billing & usage, troubleshooting, and more.
- **Security** — HSM, key hierarchy, zero-trust, compliance.
- **Reference** — API reference, request pipeline, error codes, rate limits, [glossary](/docs/reference/glossary), changelog.

## Next steps

- [What is 1claw?](/docs/concepts/what-is-1claw) — Core concepts in more detail.
- [Parts of 1claw](/docs/concepts/parts-of-1claw) — API, Dashboard, MCP, CLI, SDK: what each is for and when to use it.
- [Quickstart for humans](/docs/quickstart/humans) — Log in and store your first secret.
- [Quickstart for agents](/docs/quickstart/agents) — Get an agent token and fetch a secret.
- [MCP Server](/docs/mcp/overview) — Connect AI agents to your vault via MCP.
- [Glossary](/docs/reference/glossary) — Definitions of vault, secret, policy, agent, and other terms.


---

## MCP Deployment

---
title: MCP Deployment
description: Deploy the 1claw MCP server to Cloud Run for hosted access at mcp.1claw.xyz, or self-host on any container platform.
sidebar_position: 4
---

# MCP Deployment

## Hosted deployment (Cloud Run)

The MCP server auto-deploys to Google Cloud Run on every push to `main` that modifies `packages/mcp/**`. The GitHub Actions workflow is at `.github/workflows/deploy-mcp.yml`.

### How it works

1. Push to `main` triggers the workflow.
2. Docker image is built and pushed to Artifact Registry.
3. Cloud Run service `oneclaw-mcp` is updated with the new image.
4. The service is available at its Cloud Run URL (and at `mcp.1claw.xyz` if domain mapping is configured).

### Infrastructure (Terraform)

The Cloud Run service and domain mapping are defined in `infra/main.tf`. To set up:

```hcl
# In infra/terraform.tfvars
mcp_domain = "mcp.1claw.xyz"
```

Then run `terraform apply`. This creates:

- `google_cloud_run_v2_service.mcp` — The Cloud Run service with health checks, auto-scaling (0–5 instances), and the vault API URL injected as an environment variable.
- `google_cloud_run_domain_mapping.mcp` — Maps `mcp.1claw.xyz` to the service (requires a CNAME DNS record pointing to Cloud Run).

### Environment variables (set automatically)

| Variable | Value | Source |
|----------|-------|--------|
| `MCP_TRANSPORT` | `httpStream` | Dockerfile default |
| `PORT` | `8080` | Dockerfile default |
| `ONECLAW_BASE_URL` | Vault Cloud Run URL | Terraform |

### Health check

The server exposes `GET /health` which returns `200 OK` with body `✓ Ok`. Cloud Run uses this for startup and liveness probes.

## Self-hosting

The MCP server is a standard Node.js Docker container. You can deploy it anywhere that runs containers.

### Docker

```bash
cd packages/mcp
docker build -t my-mcp-server .
docker run -p 8080:8080 \
  -e MCP_TRANSPORT=httpStream \
  -e ONECLAW_BASE_URL=https://api.1claw.xyz \
  my-mcp-server
```

### Required configuration

| Variable | Description |
|----------|-------------|
| `MCP_TRANSPORT` | Set to `httpStream` for hosted mode |
| `PORT` | HTTP port (default: `8080`) |
| `ONECLAW_BASE_URL` | Your vault API URL |

Note: In hosted mode, auth credentials come from client request headers (`Authorization` and `X-Vault-ID`), not from environment variables. The server creates a new vault client per connection using the caller's credentials.


---

## MCP Server

---
title: MCP Server Overview
description: The 1claw MCP server gives AI agents secure, just-in-time access to secrets via the Model Context Protocol. Available as a hosted service or local stdio process.
sidebar_position: 0
---

# MCP Server

The **1claw MCP server** (`@1claw/mcp`) implements the [Model Context Protocol](https://modelcontextprotocol.io) to give AI agents secure, just-in-time access to secrets stored in a 1claw vault.

Secrets are fetched at runtime and never persisted in the LLM context window beyond the moment they are used.

## How it works

```
┌──────────────┐         MCP protocol          ┌──────────────┐
│  AI Agent    │ ◀─────────────────────────────▶│  1claw MCP   │
│  (Claude,    │   list_secrets, get_secret,    │  Server      │
│   Cursor,    │   put_secret, rotate_and_store │              │
│   GPT, etc.) │                                └──────┬───────┘
└──────────────┘                                       │
                                                       │ HTTPS
                                                       ▼
                                                ┌──────────────┐
                                                │  Vault API   │
                                                │ api.1claw.xyz│
                                                └──────────────┘
```

1. The AI agent calls an MCP tool (e.g. `get_secret`).
2. The MCP server authenticates with the vault API using an agent JWT (from agent ID + API key, or a static token).
3. The vault returns the decrypted secret value.
4. The MCP server passes the value back to the agent.
5. The agent uses the secret and discards it.

## Transport modes

| Mode           | Use case                                            | Auth                | URL                         |
| -------------- | --------------------------------------------------- | ------------------- | --------------------------- |
| **stdio**      | Local — Claude Desktop, Cursor, any MCP client      | Env vars            | N/A (runs locally)          |
| **httpStream** | Hosted — any MCP client with HTTP streaming support | Per-request headers | `https://mcp.1claw.xyz/mcp` |

## Tools

| Tool               | Description                                                         | Read/Write |
| ------------------ | ------------------------------------------------------------------- | ---------- |
| `list_secrets`     | List all secrets in the vault (metadata only, never values)         | Read       |
| `get_secret`       | Fetch the decrypted value of a secret by path                       | Read       |
| `put_secret`       | Create or update a secret (creates a new version)                   | Write      |
| `delete_secret`    | Soft-delete a secret at a given path                                | Write      |
| `describe_secret`  | Get metadata (type, version, expiry) without fetching the value     | Read       |
| `rotate_and_store` | Store a new value for an existing secret and return the new version | Write      |
| `get_env_bundle`   | Fetch an `env_bundle` secret and parse its KEY=VALUE lines as JSON  | Read       |
| `create_vault`     | Create a new vault                                                  | Write      |
| `list_vaults`      | List all accessible vaults                                          | Read       |
| `grant_access`     | Grant a user or agent access to a vault                             | Write      |
| `share_secret`     | Share a secret with someone by email                                | Write      |

## Resources

| URI               | Description                                                      |
| ----------------- | ---------------------------------------------------------------- |
| `vault://secrets` | Browsable listing of all secret paths (metadata only, no values) |

## Next steps

- [Setup Guide](/docs/mcp/setup) — Install and configure the MCP server
- [Tool Reference](/docs/mcp/tools) — Detailed documentation for each tool
- [Security](/docs/mcp/security) — Security model and best practices
- [Deployment](/docs/mcp/deployment) — Deploy the hosted MCP server


---

## MCP Security

---
title: MCP Security
description: Security model, best practices, and threat mitigations for the 1claw MCP server.
sidebar_position: 3
---

# MCP Security

## Security model

The 1claw MCP server is designed around the principle that **secrets should exist in an agent's context for the shortest possible time**.

### Secret value handling

- **Values are never logged.** When `get_secret` is called, only `"secret accessed: <path>"` appears in the MCP server logs. The actual value is never written to disk or stdout.
- **Values are never cached.** Each `get_secret` call makes a fresh request to the vault API. No secret values are stored in memory between tool calls.
- **Values are returned directly.** The decrypted value passes from the vault API through the MCP server to the agent in a single request cycle.

### Authentication

| Transport | How auth works |
|-----------|---------------|
| **stdio** | Agent token and vault ID are set as environment variables at startup. A single client is created for the process lifetime. |
| **httpStream** | Each HTTP streaming connection sends `Authorization` and `X-Vault-ID` headers. A new client is created per session. Sessions are isolated — no shared state. |

### Authorization

The MCP server itself does not enforce access control. Authorization is handled by the vault API's policy engine:

1. The MCP server authenticates as an **agent** using the agent token.
2. Every API call (list, read, write, delete) is checked against the **policies** attached to that agent.
3. If the agent doesn't have a policy granting access to a path, the vault returns `403 Forbidden`.

This means you control what the AI agent can access by configuring policies in the 1claw dashboard — the MCP server just relays requests.

### Audit trail

Every secret access through the MCP server is recorded in the vault's audit log. You can view audit events in the dashboard or query them via `GET /v1/audit/events`.

## Best practices

### Token scoping

Create dedicated agents for each use case with the minimum permissions needed:

- **Read-only agent** — Policy with only `read` permission on specific paths
- **CI/CD agent** — Policy with `read` on `config/*` and `api-keys/*`
- **Rotation agent** — Policy with `read` and `write` on paths it manages

### Path prefix isolation

Use path prefixes to organize secrets and scope agent access:

```
api-keys/stripe          → Agent A (read)
api-keys/openai          → Agent A (read)
config/prod-env          → Agent B (read)
internal/db-credentials  → No agent access
```

### Expiry and access limits

Set `expires_at` and `max_access_count` on sensitive secrets:

```
put_secret(
  path: "temp/deploy-key",
  value: "...",
  expires_at: "2026-03-01T00:00:00Z",
  max_access_count: 5
)
```

The secret auto-expires after the date or after 5 reads, whichever comes first.

### Hosted vs local

| Consideration | Hosted (`mcp.1claw.xyz`) | Local (stdio) |
|--------------|--------------------------|---------------|
| Setup complexity | Minimal (URL + headers) | Requires Node.js, build step |
| Network path | Agent → MCP server → Vault API | Agent → local MCP → Vault API |
| Token exposure | Headers sent over HTTPS | Env vars on local machine |
| Isolation | Per-session, stateless | Single process, single client |

For most use cases, the hosted mode is recommended. Use local mode when you need air-gapped operation or want to run against a self-hosted vault.

## Error handling

The MCP server translates vault API errors into clear, actionable messages:

| HTTP status | MCP error message |
|------------|-------------------|
| 404 | `No secret found at path '<path>'.` |
| 410 | `Secret at path '<path>' is expired or has exceeded its maximum access count.` |
| 402 | `Free tier quota exhausted. Upgrade your plan or add payment at https://1claw.xyz/settings/billing` |
| 403 | `Access denied` (agent doesn't have a policy for this path) |


---

## Setup Guide

---
title: MCP Setup Guide
description: Step-by-step instructions for installing and configuring the 1claw MCP server with Claude Desktop, Cursor, and other MCP clients.
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Setup Guide

## Prerequisites

Before configuring the MCP server, you need:

1. **A 1claw account** — Sign up at [1claw.xyz](https://1claw.xyz)
2. **A vault** — Create one from the dashboard
3. **An agent** — Register an agent and save the API key (`ocv_...`)
4. **A policy** — Grant the agent read access to the secret paths it needs

## Option 1: Hosted server (recommended)

The simplest setup — no local installation needed. The hosted MCP server runs at `mcp.1claw.xyz` and authenticates per-connection with a **Bearer JWT**. You get the JWT by calling the 1claw API with your **agent ID** and **API key** (`ocv_...`):

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s -X POST https://api.1claw.xyz/v1/auth/agent-token \
  -H "Content-Type: application/json" \
  -d '{"agent_id":"<your-agent-uuid>","api_key":"ocv_..."}' | jq -r '.access_token'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
import { createClient } from "@1claw/sdk";

const client = createClient({
  baseUrl: "https://api.1claw.xyz",
  agentId: "<your-agent-uuid>",
  apiKey: "ocv_...",
});
// The SDK manages token exchange and refresh automatically.
// For manual token retrieval:
const { data } = await client.auth.agentToken({
  agent_id: "<your-agent-uuid>",
  api_key: "ocv_...",
});
console.log(data.access_token);
```

</TabItem>
</Tabs>

Use the returned `access_token` as the Bearer value below. The token expires in about an hour; for long-lived use, your client may need to refresh it by calling the agent-token endpoint again.

### Claude Desktop

Add to `~/Library/Application Support/Claude/claude_desktop_config.json` (macOS) or `%APPDATA%\Claude\claude_desktop_config.json` (Windows):

```json
{
  "mcpServers": {
    "1claw": {
      "url": "https://mcp.1claw.xyz/mcp",
      "headers": {
        "Authorization": "Bearer <jwt-from-agent-token-endpoint>",
        "X-Vault-ID": "your-vault-uuid-here"
      }
    }
  }
}
```

### Cursor

Add to `.cursor/mcp.json` in your project root:

```json
{
  "mcpServers": {
    "1claw": {
      "url": "https://mcp.1claw.xyz/mcp",
      "headers": {
        "Authorization": "Bearer <jwt-from-agent-token-endpoint>",
        "X-Vault-ID": "your-vault-uuid-here"
      }
    }
  }
}
```

### Any MCP client

Any client that supports HTTP streaming can connect:

- **Endpoint:** `https://mcp.1claw.xyz/mcp`
- **Headers:** `Authorization: Bearer <jwt>` (from `POST /v1/auth/agent-token` with `agent_id` and `api_key`) and `X-Vault-ID: <vault-uuid>`

## Option 2: Local server (stdio)

Run the MCP server as a local process. Useful for development, air-gapped environments, or when you want full control. The server can use **agent ID + API key** (recommended; it exchanges them for a JWT and refreshes automatically) or a static **JWT** (expires in ~1 hour).

### Install

```bash
cd packages/mcp
pnpm install
pnpm run build
```

### Claude Desktop (recommended: agent ID + API key)

```json
{
  "mcpServers": {
    "1claw": {
      "command": "node",
      "args": ["/absolute/path/to/packages/mcp/dist/index.js"],
      "env": {
        "ONECLAW_AGENT_ID": "your-agent-uuid",
        "ONECLAW_AGENT_API_KEY": "ocv_your_agent_api_key",
        "ONECLAW_VAULT_ID": "your-vault-uuid-here"
      }
    }
  }
}
```

### Cursor (recommended: agent ID + API key)

```json
{
  "mcpServers": {
    "1claw": {
      "command": "node",
      "args": ["./packages/mcp/dist/index.js"],
      "env": {
        "ONECLAW_AGENT_ID": "${env:ONECLAW_AGENT_ID}",
        "ONECLAW_AGENT_API_KEY": "${env:ONECLAW_AGENT_API_KEY}",
        "ONECLAW_VAULT_ID": "${env:ONECLAW_VAULT_ID}"
      }
    }
  }
}
```

Then set the environment variables in your shell:

```bash
export ONECLAW_AGENT_ID="your-agent-uuid"
export ONECLAW_AGENT_API_KEY="ocv_your_agent_api_key"
export ONECLAW_VAULT_ID="your-vault-uuid-here"
```

**Alternative (static JWT):** If you prefer to pass a token yourself, set `ONECLAW_AGENT_TOKEN` to a JWT from `POST /v1/auth/agent-token` (with `agent_id` and `api_key`). The token expires in about an hour; you must refresh it manually.

### Environment variables

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `ONECLAW_AGENT_ID` | Yes* (stdio) | — | Agent UUID (from dashboard). Use with `ONECLAW_AGENT_API_KEY`. |
| `ONECLAW_AGENT_API_KEY` | Yes* (stdio) | — | Agent API key (`ocv_...`). Server exchanges for JWT and auto-refreshes. |
| `ONECLAW_AGENT_TOKEN` | Yes* (stdio) | — | Static JWT from `POST /v1/auth/agent-token` (alternative to ID + key; expires ~1 h). |
| `ONECLAW_VAULT_ID` | Yes (stdio) | — | UUID of the vault to operate on |
| `ONECLAW_BASE_URL` | No | `https://api.1claw.xyz` | Override for self-hosted vault |

\* Set either **`ONECLAW_AGENT_ID` + `ONECLAW_AGENT_API_KEY`** (recommended) or **`ONECLAW_AGENT_TOKEN`**.

## Verifying the connection

After configuration, ask your AI agent:

> "List the secrets in my 1claw vault."

The agent should call `list_secrets` and return the paths and metadata of your secrets. If you get an authentication error, verify your agent credentials (agent ID + API key, or JWT) and vault ID.

## Development tools

```bash
# Interactive CLI testing
pnpm dev

# MCP Inspector (browser UI for testing tools)
pnpm inspect
```


---

## Tool Reference

---
title: MCP Tool Reference
description: Detailed documentation for every tool provided by the 1claw MCP server, including parameters, examples, and error handling.
sidebar_position: 2
---

# Tool Reference

## list_secrets

List all secrets stored in the vault. Returns paths, types, versions, and metadata — **never secret values**.

### Parameters

| Name     | Type   | Required | Description                                      |
| -------- | ------ | -------- | ------------------------------------------------ |
| `prefix` | string | No       | Filter secrets by path prefix (e.g. `api-keys/`) |

### Example

```
Agent: "What secrets are available?"
→ list_secrets()

Found 3 secret(s):
- api-keys/stripe  (type: api_key, version: 2, expires: never)
- api-keys/openai  (type: api_key, version: 1, expires: 2026-12-31T23:59:59Z)
- passwords/db-prod  (type: password, version: 5, expires: never)
```

---

## get_secret

Fetch the decrypted value of a secret by its path. Use this immediately before making an API call that requires the credential.

### Parameters

| Name   | Type   | Required | Description                          |
| ------ | ------ | -------- | ------------------------------------ |
| `path` | string | Yes      | Secret path (e.g. `api-keys/stripe`) |

### Example

```
Agent: "I need the Stripe API key"
→ get_secret(path: "api-keys/stripe")

{"path":"api-keys/stripe","type":"api_key","version":2,"value":"sk_live_..."}
```

### Errors

| Status | Meaning                                                           |
| ------ | ----------------------------------------------------------------- |
| 404    | No secret found at this path                                      |
| 410    | Secret is expired or has exceeded its maximum access count        |
| 402    | Free tier quota exhausted — upgrade at 1claw.xyz/settings/billing |

---

## put_secret

Create a new secret or update an existing one. Each call creates a new version.

### Parameters

| Name               | Type   | Required | Description                                                                                                                            |
| ------------------ | ------ | -------- | -------------------------------------------------------------------------------------------------------------------------------------- |
| `path`             | string | Yes      | Secret path (e.g. `api-keys/stripe`)                                                                                                   |
| `value`            | string | Yes      | The secret value to store                                                                                                              |
| `type`             | string | No       | Secret type. Default: `api_key`. Options: `api_key`, `password`, `private_key`, `certificate`, `file`, `note`, `ssh_key`, `env_bundle` |
| `metadata`         | object | No       | Arbitrary JSON metadata to attach                                                                                                      |
| `expires_at`       | string | No       | ISO 8601 expiry datetime                                                                                                               |
| `max_access_count` | number | No       | Auto-expire after this many reads                                                                                                      |

### Example

```
Agent: "Store this new API key"
→ put_secret(path: "api-keys/stripe", value: "sk_live_new...", type: "api_key")

Secret stored at 'api-keys/stripe' (version 3, type: api_key).
```

---

## delete_secret

Soft-delete a secret. All versions are marked as deleted. This is reversible by an admin.

### Parameters

| Name   | Type   | Required | Description           |
| ------ | ------ | -------- | --------------------- |
| `path` | string | Yes      | Secret path to delete |

### Example

```
Agent: "Delete the old Stripe key"
→ delete_secret(path: "api-keys/old-stripe")

Secret at 'api-keys/old-stripe' has been soft-deleted.
```

---

## describe_secret

Get metadata for a secret without fetching its value. Use this to check if a secret exists or is still valid.

### Parameters

| Name   | Type   | Required | Description             |
| ------ | ------ | -------- | ----------------------- |
| `path` | string | Yes      | Secret path to describe |

### Example

```
Agent: "Is the Stripe key still valid?"
→ describe_secret(path: "api-keys/stripe")

{
  "path": "api-keys/stripe",
  "type": "api_key",
  "version": 2,
  "metadata": {},
  "created_at": "2026-01-15T10:30:00Z",
  "expires_at": null
}
```

---

## rotate_and_store

Store a new value for an existing secret, creating a new version. Useful when an agent has regenerated an API key and needs to persist it.

### Parameters

| Name    | Type   | Required | Description           |
| ------- | ------ | -------- | --------------------- |
| `path`  | string | Yes      | Secret path to rotate |
| `value` | string | Yes      | The new secret value  |

### Example

```
Agent: "I regenerated the Stripe key, store the new one"
→ rotate_and_store(path: "api-keys/stripe", value: "sk_live_rotated...")

Rotated secret at 'api-keys/stripe'. New version: 3.
```

---

## get_env_bundle

Fetch a secret of type `env_bundle`, parse its `KEY=VALUE` lines, and return a structured JSON object. Useful for injecting environment variables into subprocesses.

### Parameters

| Name   | Type   | Required | Description                    |
| ------ | ------ | -------- | ------------------------------ |
| `path` | string | Yes      | Path to an `env_bundle` secret |

### Example

```
Agent: "Get the production environment variables"
→ get_env_bundle(path: "config/prod-env")

{
  "DATABASE_URL": "postgres://...",
  "REDIS_URL": "redis://...",
  "API_KEY": "sk_..."
}
```

The secret value should contain one `KEY=VALUE` per line. Lines starting with `#` and blank lines are ignored.

---

## create_vault

Create a new vault for organizing secrets.

### Parameters

| Name          | Type   | Required | Description                        |
| ------------- | ------ | -------- | ---------------------------------- |
| `name`        | string | Yes      | Vault name                         |
| `description` | string | No       | Description of the vault's purpose |

### Example

```
Agent: "Create a vault for production API keys"
→ create_vault(name: "prod-keys", description: "Production API credentials")

Vault 'prod-keys' created (id: ae370174-...).
```

---

## list_vaults

List all vaults accessible to the authenticated agent.

### Parameters

None.

### Example

```
Agent: "What vaults do I have access to?"
→ list_vaults()

Found 2 vault(s):
- prod-keys (ae370174-...)
- staging (bf481285-...)
```

---

## grant_access

Grant a user or agent access to a vault by creating an access policy.

### Parameters

| Name                  | Type     | Required | Description                                                           |
| --------------------- | -------- | -------- | --------------------------------------------------------------------- |
| `vault_id`            | string   | Yes      | UUID of the vault                                                     |
| `principal_type`      | string   | Yes      | `user` or `agent`                                                     |
| `principal_id`        | string   | Yes      | UUID of the user or agent                                             |
| `permissions`         | string[] | No       | Array of permissions: `read`, `write`, `delete` (default: `["read"]`) |
| `secret_path_pattern` | string   | No       | Glob pattern to restrict access (default: `**` — all secrets)         |

### Example

```
Agent: "Give agent abc123 read access to the prod-keys vault"
→ grant_access(vault_id: "ae370174-...", principal_type: "agent", principal_id: "abc123", permissions: ["read"])

Access granted to agent abc123 on vault prod-keys.
```

---

## share_secret

Share a secret with your creator (the human who registered you), a specific user or agent by ID, or create an open link. Use `recipient_type: "creator"` for the simplest agent-to-human sharing — no UUID or email needed.

### Parameters

| Name               | Type   | Required | Description                                                    |
| ------------------ | ------ | -------- | -------------------------------------------------------------- |
| `secret_id`        | string | Yes      | UUID of the secret to share                                    |
| `recipient_type`   | string | Yes      | `creator`, `user`, `agent`, or `anyone_with_link`              |
| `recipient_id`     | string | No       | UUID of the user or agent (required for `user`/`agent` types)  |
| `expires_at`       | string | Yes      | ISO 8601 expiry datetime (e.g. `2026-03-01T00:00:00Z`)         |
| `max_access_count` | number | No       | Maximum number of times the share can be accessed (default: 5) |

### Examples

```
Agent: "Share this key with the person who set me up"
→ share_secret(secret_id: "cf592...", recipient_type: "creator", expires_at: "2026-03-01T00:00:00Z")

Secret shared with your creator. Share ID: df703...
The recipient must accept the share before they can access the secret.
```

```
Agent: "Share this with agent abc123"
→ share_secret(secret_id: "cf592...", recipient_type: "agent", recipient_id: "abc123", max_access_count: 3)

Secret shared with agent abc123. Share ID: ef814...
```


---

## Quickstart for agents

---
title: Quickstart for agents
description: Exchange an agent API key for a JWT, then list and fetch secrets the agent is allowed to access.
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Quickstart for agents

An **agent** is registered by a human; when registered, it receives an **API key** (`ocv_...`). The agent (or its runtime) exchanges this key for a short-lived JWT, then calls the same API to list and fetch secrets. Access is enforced by **policies** created by the human.

## 1. Get an agent token

You need the **agent ID** (UUID) and the **API key** that was returned when the agent was registered (or rotated).

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST https://api.1claw.xyz/v1/auth/agent-token \
  -H "Content-Type: application/json" \
  -d '{
    "agent_id": "ec7e0226-30f0-4dda-b169-f060a3502603",
    "api_key": "ocv_W3_eYj0BSdTjChKwCKRYuZJacmmhVn4ozWIxHV-zlEs"
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
import { createClient } from "@1claw/sdk";

// Agent credentials — the SDK exchanges them for a JWT automatically
// and refreshes it before expiry
const client = createClient({
  baseUrl: "https://api.1claw.xyz",
  agentId: "ec7e0226-30f0-4dda-b169-f060a3502603",
  apiKey: "ocv_W3_eYj0BSdTjChKwCKRYuZJacmmhVn4ozWIxHV-zlEs",
});
```

</TabItem>
</Tabs>

**Response:**

```json
{
  "access_token": "eyJhbGciOiJFZERTQSIs...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

Use this as `Authorization: Bearer <access_token>` for subsequent requests. Token is short-lived (e.g. 1 hour).

## 2. List secrets you can access

With the agent JWT you can list secrets in a vault (metadata only). You only see secrets for vaults and paths your policies allow.

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
export TOKEN="<agent access_token>"
export VAULT_ID="ae370174-9aee-4b02-ba7c-d1519930c709"

curl -s "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets" \
  -H "Authorization: Bearer $TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const VAULT_ID = "ae370174-9aee-4b02-ba7c-d1519930c709";

const { data } = await client.secrets.list(VAULT_ID);
for (const s of data.secrets) {
  console.log(`${s.path} (${s.type}, v${s.version})`);
}
```

</TabItem>
</Tabs>

**Response:** `{ "secrets": [ { "id", "path", "type", "version", "metadata", "created_at", "expires_at" }, ... ] }`

## 3. Fetch a secret value

Request a secret by vault ID and path. The server checks policy; if the agent has read access, it decrypts and returns the value.

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: secret } = await client.secrets.get(VAULT_ID, "api-keys/openai");
// Use the value for the intended call — don't log or persist it
console.log(`Retrieved ${secret.path} (${secret.type}, v${secret.version})`);
```

</TabItem>
</Tabs>

**Response (200):** Includes `value` (plaintext) and metadata. Use the value only for the intended call; don't log or persist it.

If the agent has no read permission for that path, or the secret is expired/deleted, you get **403** or **404/410**.

## Important

- **Store the API key securely** — In the agent's config or secrets store, not in code or prompts.
- **Refresh the JWT** before it expires — Call `POST /v1/auth/agent-token` again when `expires_in` has passed. The TypeScript SDK handles this automatically when you pass `agentId` + `apiKey`.
- **Same API as humans** — Same base URL and paths; only the way you get the JWT (agent-token vs email/password or Google) and the permissions (policies) differ.

## Next steps

- [Agent API overview](/docs/agent-api/overview) — Auth and endpoints in one place.
- [Give an agent access](/docs/guides/give-agent-access) — How a human registers an agent and creates a policy.
- [Fetch secret](/docs/agent-api/fetch-secret) — Full request/response and errors.


---

## Quickstart for humans

---
title: Quickstart for humans
description: Log in with email and password, create a vault, store a secret, and read it back using the Human API.
sidebar_position: 0
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Quickstart for humans

This page gets you from zero to a stored secret in a few minutes: obtain a JWT, create a vault, then create and read a secret.

## 1. Get a JWT

Exchange email and password for an access token. Base URL: `https://api.1claw.xyz` (or your Cloud Run URL).

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -X POST https://api.1claw.xyz/v1/auth/token \
  -H "Content-Type: application/json" \
  -d '{"email":"you@example.com","password":"your-password"}'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
import { createClient } from "@1claw/sdk";

const client = createClient({ baseUrl: "https://api.1claw.xyz" });

await client.auth.login({
  email: "you@example.com",
  password: "your-password",
});
// Client is now authenticated — JWT is managed internally
```

</TabItem>
</Tabs>

**Response:**

```json
{
  "access_token": "eyJhbGciOiJFZERTQSIs...",
  "token_type": "Bearer",
  "expires_in": 900
}
```

Use `access_token` as a Bearer token in all following requests.

## 2. Create a vault

Vaults are containers for secrets. Each vault has its own HSM-backed key.

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
export TOKEN="<your access_token>"

curl -X POST https://api.1claw.xyz/v1/vaults \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"My Vault","description":"Secrets for my app"}'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: vault } = await client.vault.create({
  name: "My Vault",
  description: "Secrets for my app",
});
console.log(vault.id); // ae370174-9aee-4b02-ba7c-d1519930c709
```

</TabItem>
</Tabs>

**Response (201):**

```json
{
  "id": "ae370174-9aee-4b02-ba7c-d1519930c709",
  "name": "My Vault",
  "description": "Secrets for my app",
  "created_by": "2a57eb5e-caac-4e34-9685-b94c37458eb1",
  "created_at": "2026-02-18T12:00:00Z"
}
```

Save the `id`; you'll use it as `vault_id`.

## 3. Store a secret

Secrets live at **paths** inside a vault. Paths are slash-separated (e.g. `api-keys/stripe`, `passwords/db`).

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
export VAULT_ID="ae370174-9aee-4b02-ba7c-d1519930c709"

curl -X PUT "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "api_key",
    "value": "sk-proj-...",
    "metadata": {"tags": ["openai", "production"]}
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: secret } = await client.secrets.set(
  vault.id,
  "api-keys/openai",
  "sk-proj-...",
  {
    type: "api_key",
    metadata: { tags: ["openai", "production"] },
  },
);
console.log(secret.path, `v${secret.version}`); // api-keys/openai v1
```

</TabItem>
</Tabs>

**Response (201):**

```json
{
  "id": "599dd304-920c-4459-ae07-d62a3515381b",
  "path": "api-keys/openai",
  "type": "api_key",
  "version": 1,
  "metadata": {"tags": ["openai", "production"]},
  "created_at": "2026-02-18T12:01:00Z"
}
```

The secret **value** is never returned after creation; only metadata.

## 4. Read the secret

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data: secret } = await client.secrets.get(vault.id, "api-keys/openai");
console.log(secret.value); // sk-proj-... (use securely, don't log in production)
```

</TabItem>
</Tabs>

**Response (200):** Includes decrypted `value` plus metadata. Keep this response secure.

## 5. List secrets (metadata only)

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets" \
  -H "Authorization: Bearer $TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data } = await client.secrets.list(vault.id);
for (const s of data.secrets) {
  console.log(`${s.path} (${s.type}, v${s.version})`);
}
```

</TabItem>
</Tabs>

Returns `{ "secrets": [ ... ] }` with id, path, type, version, metadata, created_at, expires_at — **no** value.

## Next steps

- [Human API overview](/docs/human-api/overview) — All endpoints and auth options.
- [Create a secret](/docs/human-api/secrets/create) — Full request/response and options.
- [Give an agent access](/docs/guides/give-agent-access) — Register an agent and grant read access.


---

## Quickstart

---
title: Quickstart
description: Get started with 1claw in minutes — choose your path below.
slug: /quickstart
---

# Quickstart

Get from zero to a stored (or fetched) secret in a few minutes. Choose the guide that matches your role:

## For humans

You own the secrets. Sign up, create a vault, store a secret, and read it back.

**You will learn to:**

- Obtain a JWT via email/password or Google
- Create a vault
- Store and retrieve a secret

[Start the human quickstart &rarr;](/docs/quickstart/humans)

## For agents

An agent accesses secrets that a human has shared. Exchange an API key for a JWT, then list and fetch secrets.

**You will learn to:**

- Exchange an agent API key for a short-lived JWT
- List accessible secrets
- Fetch a decrypted secret value

[Start the agent quickstart &rarr;](/docs/quickstart/agents)

## Prerequisites

| Requirement  | Details                                                                     |
| ------------ | --------------------------------------------------------------------------- |
| **Account**  | Sign up at [1claw.xyz](https://1claw.xyz) (free tier: 1,000 requests/month) |
| **curl**     | All examples use `curl`; any HTTP client works                              |
| **Base URL** | `https://api.1claw.xyz`                                                     |


---

## API & MCP Testing

---
title: API & MCP Testing
description: Complete guide to testing the 1claw API and MCP server using curl, including every endpoint group with working examples.
sidebar_position: 1
---

# API & MCP Testing

This page provides ready-to-run `curl` commands for every area of the 1claw API and MCP server. Use these to verify your deployment, debug integrations, or explore the API interactively.

## Setup

Set these environment variables before running the examples:

```bash
export API="https://api.1claw.xyz"
```

---

## 1. Health checks (no auth required)

```bash
# Service health
curl -s "$API/v1/health" | python3 -m json.tool

# HSM connectivity
curl -s "$API/v1/health/hsm" | python3 -m json.tool
```

Expected: `{ "status": "ok" }` for both.

---

## 2. Authentication

### Sign up (new account)

```bash
curl -s -X POST "$API/v1/auth/signup" \
  -H "Content-Type: application/json" \
  -d '{"email":"you@example.com","password":"YourSecurePassword123!"}' \
  | python3 -m json.tool
```

### Email/password login

```bash
curl -s -X POST "$API/v1/auth/token" \
  -H "Content-Type: application/json" \
  -d '{"email":"you@example.com","password":"YourSecurePassword123!"}' \
  | python3 -m json.tool
```

Save the `access_token`:

```bash
export TOKEN=$(curl -s -X POST "$API/v1/auth/token" \
  -H "Content-Type: application/json" \
  -d '{"email":"you@example.com","password":"your-password"}' \
  | python3 -c "import sys,json; print(json.load(sys.stdin)['access_token'])")
```

### Google OAuth login

```bash
curl -s -X POST "$API/v1/auth/google" \
  -H "Content-Type: application/json" \
  -d '{"id_token":"<google-id-token>"}' \
  | python3 -m json.tool
```

### Refresh token

```bash
curl -s -X POST "$API/v1/auth/refresh" \
  -H "Content-Type: application/json" \
  -d '{"refresh_token":"<refresh_token>"}' \
  | python3 -m json.tool
```

### Revoke token

```bash
curl -s -X DELETE "$API/v1/auth/token" \
  -H "Authorization: Bearer $TOKEN"
```

### Change password

```bash
curl -s -X POST "$API/v1/auth/change-password" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"current_password":"old","new_password":"new"}' \
  | python3 -m json.tool
```

---

## 3. Personal API Keys

```bash
# Create an API key
curl -s -X POST "$API/v1/auth/api-keys" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"my-ci-key"}' \
  | python3 -m json.tool

# List API keys
curl -s "$API/v1/auth/api-keys" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Exchange API key for JWT
curl -s -X POST "$API/v1/auth/api-key-token" \
  -H "Content-Type: application/json" \
  -d '{"api_key":"1claw_..."}' \
  | python3 -m json.tool

# Revoke an API key
curl -s -X DELETE "$API/v1/auth/api-keys/<key_id>" \
  -H "Authorization: Bearer $TOKEN"
```

---

## 4. Vaults

```bash
# Create vault
curl -s -X POST "$API/v1/vaults" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"test-vault","description":"Testing"}' \
  | python3 -m json.tool

# List vaults
curl -s "$API/v1/vaults" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Get a specific vault
export VAULT_ID="<vault-id-from-create>"
curl -s "$API/v1/vaults/$VAULT_ID" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Delete vault
curl -s -X DELETE "$API/v1/vaults/$VAULT_ID" \
  -H "Authorization: Bearer $TOKEN"
```

---

## 5. Secrets

```bash
# Store a secret (PUT creates or updates)
curl -s -X PUT "$API/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "type": "api_key",
    "value": "sk-proj-test123",
    "metadata": {"env": "test"}
  }' \
  | python3 -m json.tool

# List secrets (metadata only, no values)
curl -s "$API/v1/vaults/$VAULT_ID/secrets" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Get secret value (decrypted)
curl -s "$API/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Store a nested-path secret
curl -s -X PUT "$API/v1/vaults/$VAULT_ID/secrets/config/prod/database" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"password","value":"postgres://..."}' \
  | python3 -m json.tool

# Delete a secret
curl -s -X DELETE "$API/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN"
```

---

## 6. Policies

Policies control which agents (or users) can access which secrets.

```bash
# Create a policy granting an agent read access
curl -s -X POST "$API/v1/vaults/$VAULT_ID/policies" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "secret_path_pattern": "api-keys/**",
    "principal_type": "agent",
    "principal_id": "<agent-uuid>",
    "permissions": ["read"]
  }' \
  | python3 -m json.tool

# List policies for a vault
curl -s "$API/v1/vaults/$VAULT_ID/policies" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Update a policy
curl -s -X PUT "$API/v1/vaults/$VAULT_ID/policies/<policy_id>" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "permissions": ["read", "write"]
  }' \
  | python3 -m json.tool

# Delete a policy
curl -s -X DELETE "$API/v1/vaults/$VAULT_ID/policies/<policy_id>" \
  -H "Authorization: Bearer $TOKEN"
```

---

## 7. Agents

```bash
# Register an agent
curl -s -X POST "$API/v1/agents" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "test-agent",
    "description": "A test agent",
    "crypto_proxy_enabled": false
  }' \
  | python3 -m json.tool
# Save the returned agent_id and api_key (ocv_...)

# List agents
curl -s "$API/v1/agents" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Get a single agent
export AGENT_ID="<agent-id>"
curl -s "$API/v1/agents/$AGENT_ID" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Update agent
curl -s -X PATCH "$API/v1/agents/$AGENT_ID" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"renamed-agent","crypto_proxy_enabled":true}' \
  | python3 -m json.tool

# Rotate agent API key
curl -s -X POST "$API/v1/agents/$AGENT_ID/rotate-key" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Delete (deactivate) agent
curl -s -X DELETE "$API/v1/agents/$AGENT_ID" \
  -H "Authorization: Bearer $TOKEN"
```

### Agent self-inspection

```bash
# Get the agent's own profile (includes created_by — the human who registered it)
curl -s "$API/v1/agents/me" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  | python3 -m json.tool
```

### Agent authentication

```bash
# Exchange agent API key for JWT
curl -s -X POST "$API/v1/auth/agent-token" \
  -H "Content-Type: application/json" \
  -d '{
    "agent_id": "<agent-uuid>",
    "api_key": "ocv_..."
  }' \
  | python3 -m json.tool

# Use the agent token to fetch secrets
export AGENT_TOKEN="<agent-access-token>"
curl -s "$API/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  | python3 -m json.tool
```

---

## 8. Sharing

```bash
# Agent shares a secret back with its creator (the human who registered it)
curl -s -X POST "$API/v1/secrets/<secret_id>/share" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "recipient_type": "creator",
    "expires_at": "2026-03-01T00:00:00Z",
    "max_access_count": 5
  }' \
  | python3 -m json.tool

# Create a share (by secret ID, with email invite — humans only)
curl -s -X POST "$API/v1/secrets/<secret_id>/share" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "recipient_type": "external_email",
    "email": "colleague@example.com",
    "expires_at": "2026-03-01T00:00:00Z",
    "max_access_count": 5
  }' \
  | python3 -m json.tool

# List shares you created
curl -s "$API/v1/shares/outbound" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# List shares sent to you
curl -s "$API/v1/shares/inbound" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Accept an inbound share
curl -s -X POST "$API/v1/shares/<share_id>/accept" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Decline an inbound share
curl -s -X POST "$API/v1/shares/<share_id>/decline" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Access shared secret (public, no auth — uses share link)
curl -s "$API/v1/share/<share_id>" \
  | python3 -m json.tool

# Revoke a share
curl -s -X DELETE "$API/v1/share/<share_id>" \
  -H "Authorization: Bearer $TOKEN"
```

---

## 9. Chains

```bash
# List all supported chains
curl -s "$API/v1/chains" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Get a specific chain (by ID or chain_id)
curl -s "$API/v1/chains/1" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool
```

---

## 10. Transactions (Crypto Proxy)

The agent must have `crypto_proxy_enabled: true`. Use the agent's JWT. When enabled, the agent is blocked from reading `private_key` and `ssh_key` secrets directly — it must use these proxy endpoints instead.

```bash
# Submit a transaction
curl -s -X POST "$API/v1/agents/$AGENT_ID/transactions" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "chain_id": 1,
    "to": "0x742d35Cc6634C0532925a3b844Bc9e7595f2bD18",
    "value": "0x0",
    "data": "0x"
  }' \
  | python3 -m json.tool

# List transactions for an agent
curl -s "$API/v1/agents/$AGENT_ID/transactions" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  | python3 -m json.tool

# Get a specific transaction
curl -s "$API/v1/agents/$AGENT_ID/transactions/<tx_id>" \
  -H "Authorization: Bearer $AGENT_TOKEN" \
  | python3 -m json.tool
```

---

## 11. Billing & Usage

```bash
# Usage summary
curl -s "$API/v1/billing/usage" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Usage history
curl -s "$API/v1/billing/history" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool
```

---

## 12. Audit log

```bash
# Query audit events (recent)
curl -s "$API/v1/audit/events" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# With query parameters
curl -s "$API/v1/audit/events?limit=10&action=secret.read" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool
```

---

## 13. Organization

```bash
# List org members
curl -s "$API/v1/org/members" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Invite a member
curl -s -X POST "$API/v1/org/invite" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"email":"newmember@example.com","role":"member"}' \
  | python3 -m json.tool

# Update member role
curl -s -X PATCH "$API/v1/org/members/<user_id>" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"role":"admin"}' \
  | python3 -m json.tool

# Remove member
curl -s -X DELETE "$API/v1/org/members/<user_id>" \
  -H "Authorization: Bearer $TOKEN"
```

---

## 14. Security (IP rules)

```bash
# List IP rules
curl -s "$API/v1/security/ip-rules" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Create an allow rule
curl -s -X POST "$API/v1/security/ip-rules" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"cidr":"203.0.113.0/24","rule_type":"allow","description":"Office network"}' \
  | python3 -m json.tool

# Create a block rule
curl -s -X POST "$API/v1/security/ip-rules" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"cidr":"198.51.100.5/32","rule_type":"block","description":"Suspicious IP"}' \
  | python3 -m json.tool

# Delete an IP rule
curl -s -X DELETE "$API/v1/security/ip-rules/<rule_id>" \
  -H "Authorization: Bearer $TOKEN"
```

---

## 15. Admin endpoints

These require admin/super-admin privileges.

```bash
# List all settings
curl -s "$API/v1/admin/settings" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Update a setting
curl -s -X PUT "$API/v1/admin/settings/maintenance_mode" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"value":"false"}' \
  | python3 -m json.tool

# Get x402 payment configuration
curl -s "$API/v1/admin/x402" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Update x402 config
curl -s -X PUT "$API/v1/admin/x402" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "enabled": true,
    "facilitator_url": "https://api.cdp.coinbase.com/platform/v2/x402",
    "payment_address": "0x...",
    "network": "base-sepolia"
  }' \
  | python3 -m json.tool

# List all users
curl -s "$API/v1/admin/users" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

# Delete user (platform admin only; cascade: share links, agent created_by)
# curl -s -o /dev/null -w "%{http_code}" -X DELETE "$API/v1/admin/users/<user_id>" \
#   -H "Authorization: Bearer $TOKEN"

# Manage chains (admin)
curl -s "$API/v1/admin/chains" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool

curl -s -X POST "$API/v1/admin/chains" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Polygon",
    "chain_id": 137,
    "rpc_url": "https://polygon-rpc.com",
    "explorer_url": "https://polygonscan.com",
    "is_testnet": false,
    "is_enabled": true
  }' \
  | python3 -m json.tool

# Get/update org limits
curl -s "$API/v1/admin/orgs/<org_id>/limits" \
  -H "Authorization: Bearer $TOKEN" \
  | python3 -m json.tool
```

---

## 16. MCP Server Testing

The MCP server runs as a stdio process. You can test it with `npx`:

### Install and configure

```bash
npm install -g @1claw/mcp
```

Or add to your MCP client configuration (e.g. Claude Desktop, Cursor):

```json
{
    "mcpServers": {
        "1claw": {
            "command": "npx",
            "args": ["-y", "@1claw/mcp"],
            "env": {
                "ONECLAW_API_URL": "https://api.1claw.xyz",
                "ONECLAW_AGENT_ID": "<agent-uuid>",
                "ONECLAW_API_KEY": "ocv_..."
            }
        }
    }
}
```

### Test MCP tools via curl (HTTP wrapper)

If you run the MCP server with an HTTP transport (e.g. via `mcp-proxy` or SSE), you can test tools directly:

```bash
export MCP="http://localhost:3001"

# List vaults
curl -s -X POST "$MCP" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "tools/call",
    "params": {
      "name": "list_vaults",
      "arguments": {}
    }
  }' | python3 -m json.tool

# List secrets
curl -s -X POST "$MCP" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 2,
    "method": "tools/call",
    "params": {
      "name": "list_secrets",
      "arguments": {"prefix": "api-keys/"}
    }
  }' | python3 -m json.tool

# Get a secret
curl -s -X POST "$MCP" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 3,
    "method": "tools/call",
    "params": {
      "name": "get_secret",
      "arguments": {"path": "api-keys/openai"}
    }
  }' | python3 -m json.tool

# Store a secret
curl -s -X POST "$MCP" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 4,
    "method": "tools/call",
    "params": {
      "name": "put_secret",
      "arguments": {
        "path": "api-keys/new-key",
        "value": "sk-test-123",
        "type": "api_key"
      }
    }
  }' | python3 -m json.tool

# Describe a secret (metadata only)
curl -s -X POST "$MCP" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 5,
    "method": "tools/call",
    "params": {
      "name": "describe_secret",
      "arguments": {"path": "api-keys/openai"}
    }
  }' | python3 -m json.tool

# Rotate a secret
curl -s -X POST "$MCP" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 6,
    "method": "tools/call",
    "params": {
      "name": "rotate_and_store",
      "arguments": {
        "path": "api-keys/openai",
        "value": "sk-new-rotated-value"
      }
    }
  }' | python3 -m json.tool

# Get env bundle
curl -s -X POST "$MCP" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 7,
    "method": "tools/call",
    "params": {
      "name": "get_env_bundle",
      "arguments": {"path": "config/prod-env"}
    }
  }' | python3 -m json.tool

# Create vault
curl -s -X POST "$MCP" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 8,
    "method": "tools/call",
    "params": {
      "name": "create_vault",
      "arguments": {"name": "test-vault", "description": "Created via MCP"}
    }
  }' | python3 -m json.tool

# Grant access
curl -s -X POST "$MCP" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 9,
    "method": "tools/call",
    "params": {
      "name": "grant_access",
      "arguments": {
        "vault_id": "<vault-uuid>",
        "principal_type": "agent",
        "principal_id": "<agent-uuid>",
        "permissions": ["read"]
      }
    }
  }' | python3 -m json.tool

# Share a secret
curl -s -X POST "$MCP" \
  -H "Content-Type: application/json" \
  -d '{
    "jsonrpc": "2.0",
    "id": 10,
    "method": "tools/call",
    "params": {
      "name": "share_secret",
      "arguments": {
        "secret_id": "<secret-uuid>",
        "email": "colleague@example.com",
        "expires_at": "2026-03-01T00:00:00Z",
        "max_access_count": 5
      }
    }
  }' | python3 -m json.tool
```

### Test MCP via stdio (interactive)

For direct stdio testing, pipe JSON-RPC messages:

```bash
echo '{"jsonrpc":"2.0","id":1,"method":"tools/list","params":{}}' | \
  ONECLAW_API_URL=https://api.1claw.xyz \
  ONECLAW_AGENT_ID=<agent-uuid> \
  ONECLAW_API_KEY=ocv_... \
  npx @1claw/mcp
```

---

## Tips

- **Pretty-print JSON**: Pipe any response through `python3 -m json.tool` or `jq`.
- **Save tokens as variables**: Use the token-extraction one-liner from section 2.
- **HTTP status codes**: Add `-w "\n%{http_code}\n"` to any curl command to see the status code.
- **Verbose mode**: Add `-v` to see full request/response headers.
- **x402 payment**: If an endpoint returns `402`, include a payment header as configured by your x402 setup.


---

## API reference

---
title: API reference
description: Complete list of all v1 API endpoints for the 1claw vault, grouped by domain.
sidebar_position: 0
---

# API reference

The canonical API spec is the **OpenAPI 3.1** document shipped with the project. It defines all paths, request/response schemas, and error shapes.

## Base URL

- **Production:** `https://api.1claw.xyz`
- **Dashboard proxy:** `https://1claw.xyz/api` (proxies to the same API)

All endpoints are under **/v1**.

---

## Public (no auth)

| Method | Path                  | Description                                           |
| ------ | --------------------- | ----------------------------------------------------- |
| GET    | `/v1/health`          | Service health                                        |
| GET    | `/v1/health/hsm`      | HSM connectivity                                      |
| GET    | `/v1/share/:share_id` | Access a shared secret (checks expiry + access count) |

## Authentication

| Method | Path                       | Description                                  |
| ------ | -------------------------- | -------------------------------------------- |
| POST   | `/v1/auth/signup`          | Self-service signup (email + password) → JWT |
| POST   | `/v1/auth/token`           | Email/password → JWT                         |
| POST   | `/v1/auth/agent-token`     | Agent ID + API key → JWT                     |
| POST   | `/v1/auth/api-key-token`   | Personal API key → JWT                       |
| POST   | `/v1/auth/google`          | Google id_token → JWT                        |
| DELETE | `/v1/auth/token`           | Revoke token                                 |
| POST   | `/v1/auth/change-password` | Change password                              |

## Account Management

| Method | Path           | Description                                  |
| ------ | -------------- | -------------------------------------------- |
| GET    | `/v1/auth/me`  | Get current user profile                     |
| PATCH  | `/v1/auth/me`  | Update profile (display name, marketing opt-in) |
| DELETE | `/v1/auth/me`  | Delete account and all associated data       |

## MFA (Two-Factor Authentication)

| Method | Path                       | Description                        |
| ------ | -------------------------- | ---------------------------------- |
| GET    | `/v1/auth/mfa/status`      | Check MFA enrollment status        |
| POST   | `/v1/auth/mfa/setup`       | Begin TOTP MFA enrollment          |
| POST   | `/v1/auth/mfa/verify-setup`| Verify TOTP code to complete setup |
| POST   | `/v1/auth/mfa/verify`      | Verify MFA code during login (public) |
| DELETE | `/v1/auth/mfa`             | Disable MFA (requires code or password) |

## Device Authorization (CLI Login)

| Method | Path                                 | Description                      |
| ------ | ------------------------------------ | -------------------------------- |
| POST   | `/v1/auth/device/code`               | Request device authorization code |
| POST   | `/v1/auth/device/token`              | Poll for device authorization token |
| GET    | `/v1/auth/device/code/:user_code`    | Check device code status (public) |
| POST   | `/v1/auth/device/approve`            | Approve CLI device login          |
| POST   | `/v1/auth/device/deny`               | Deny CLI device login             |

## Personal API Keys

| Method | Path                        | Description    |
| ------ | --------------------------- | -------------- |
| POST   | `/v1/auth/api-keys`         | Create API key |
| GET    | `/v1/auth/api-keys`         | List API keys  |
| DELETE | `/v1/auth/api-keys/:key_id` | Revoke API key |

## Vaults

| Method | Path                   | Description  |
| ------ | ---------------------- | ------------ |
| POST   | `/v1/vaults`           | Create vault |
| GET    | `/v1/vaults`           | List vaults  |
| GET    | `/v1/vaults/:vault_id` | Get vault    |
| DELETE | `/v1/vaults/:vault_id` | Delete vault |

## CMEK (Customer-Managed Encryption Keys)

| Method | Path                                           | Description                    |
| ------ | ---------------------------------------------- | ------------------------------ |
| POST   | `/v1/vaults/:vault_id/cmek`                    | Enable CMEK on a vault         |
| DELETE | `/v1/vaults/:vault_id/cmek`                    | Disable CMEK on a vault        |
| POST   | `/v1/vaults/:vault_id/cmek-rotate`             | Start CMEK key rotation job    |
| GET    | `/v1/vaults/:vault_id/cmek-rotate/:job_id`     | Get rotation job status        |

## Secrets

| Method | Path                                 | Description                  |
| ------ | ------------------------------------ | ---------------------------- |
| GET    | `/v1/vaults/:vault_id/secrets`       | List secrets (metadata only) |
| PUT    | `/v1/vaults/:vault_id/secrets/*path` | Create or update secret      |
| GET    | `/v1/vaults/:vault_id/secrets/*path` | Get secret value (decrypted) |
| DELETE | `/v1/vaults/:vault_id/secrets/*path` | Soft-delete secret           |

## Policies

| Method | Path                                       | Description   |
| ------ | ------------------------------------------ | ------------- |
| POST   | `/v1/vaults/:vault_id/policies`            | Create policy |
| GET    | `/v1/vaults/:vault_id/policies`            | List policies |
| PUT    | `/v1/vaults/:vault_id/policies/:policy_id` | Update policy |
| DELETE | `/v1/vaults/:vault_id/policies/:policy_id` | Delete policy |

## Agents

| Method | Path                              | Description                                             |
| ------ | --------------------------------- | ------------------------------------------------------- |
| POST   | `/v1/agents`                      | Register agent                                          |
| GET    | `/v1/agents`                      | List agents                                             |
| GET    | `/v1/agents/me`                   | Get calling agent's own profile (includes `created_by`) |
| GET    | `/v1/agents/:agent_id`            | Get agent                                               |
| PATCH  | `/v1/agents/:agent_id`            | Update agent (name, description, crypto_proxy_enabled)  |
| DELETE | `/v1/agents/:agent_id`            | Deactivate agent                                        |
| POST   | `/v1/agents/:agent_id/rotate-key` | Rotate agent API key                                    |

## Sharing

| Method | Path                           | Description                                                                     |
| ------ | ------------------------------ | ------------------------------------------------------------------------------- |
| POST   | `/v1/secrets/:secret_id/share` | Create share (`creator`, `user`, `agent`, `external_email`, `anyone_with_link`) |
| GET    | `/v1/shares/outbound`          | List shares you created                                                         |
| GET    | `/v1/shares/inbound`           | List shares sent to you                                                         |
| POST   | `/v1/shares/:share_id/accept`  | Accept an inbound share                                                         |
| POST   | `/v1/shares/:share_id/decline` | Decline an inbound share                                                        |
| DELETE | `/v1/share/:share_id`          | Revoke share (creator only)                                                     |

## Chains (public, no auth)

| Method | Path                     | Description                      |
| ------ | ------------------------ | -------------------------------- |
| GET    | `/v1/chains`             | List supported blockchain chains |
| GET    | `/v1/chains/:identifier` | Get chain by ID or chain_id      |

## Transactions (Crypto Proxy)

Requires `crypto_proxy_enabled: true` on the agent. When enabled, the agent is also **blocked** from reading `private_key` and `ssh_key` type secrets through the standard secrets endpoint — it must use the proxy to sign transactions.

| Method | Path                                                | Description                                                    |
| ------ | --------------------------------------------------- | -------------------------------------------------------------- |
| POST   | `/v1/agents/:agent_id/transactions`                 | Submit a transaction (supports `simulate_first` flag)          |
| GET    | `/v1/agents/:agent_id/transactions`                 | List agent transactions                                        |
| GET    | `/v1/agents/:agent_id/transactions/:tx_id`          | Get transaction details                                        |
| POST   | `/v1/agents/:agent_id/transactions/simulate`        | Simulate a transaction via Tenderly (no signing)               |
| POST   | `/v1/agents/:agent_id/transactions/simulate-bundle` | Simulate a bundle of sequential transactions (approve + swap)  |

## Billing & Usage

| Method | Path                  | Description                    |
| ------ | --------------------- | ------------------------------ |
| GET    | `/v1/billing/usage`   | Usage summary (current period) |
| GET    | `/v1/billing/history` | Usage history                  |

## Billing V2: Subscriptions & Credits

| Method | Path                               | Description                                           |
| ------ | ---------------------------------- | ----------------------------------------------------- |
| POST   | `/v1/billing/subscribe`            | Start subscription checkout (Stripe)                  |
| POST   | `/v1/billing/portal`               | Open Stripe customer portal                           |
| GET    | `/v1/billing/subscription`         | Full subscription + usage + credits summary           |
| POST   | `/v1/billing/credits/topup`        | Start credit top-up checkout (Stripe)                 |
| GET    | `/v1/billing/credits/balance`      | Credit balance + expiring credits                     |
| GET    | `/v1/billing/credits/transactions` | Paginated credit transaction ledger                   |
| PATCH  | `/v1/billing/overage-method`       | Toggle overage method (credits or x402)               |
| POST   | `/v1/billing/webhooks`             | Stripe webhook handler (no auth — signature verified) |

## Audit

| Method | Path               | Description        |
| ------ | ------------------ | ------------------ |
| GET    | `/v1/audit/events` | Query audit events |

## Organization

| Method | Path                       | Description            |
| ------ | -------------------------- | ---------------------- |
| GET    | `/v1/org/members`          | List org members       |
| POST   | `/v1/org/invite`           | Invite member by email |
| PATCH  | `/v1/org/members/:user_id` | Update member role     |
| DELETE | `/v1/org/members/:user_id` | Remove member          |

## Security (IP Rules)

| Method | Path                             | Description               |
| ------ | -------------------------------- | ------------------------- |
| GET    | `/v1/security/ip-rules`          | List IP allow/block rules |
| POST   | `/v1/security/ip-rules`          | Create IP rule            |
| DELETE | `/v1/security/ip-rules/:rule_id` | Delete IP rule            |

## Admin

Admin endpoints are for platform operators only. They are not documented in detail here; see your internal operations documentation.

| Method | Path                            | Description                  |
| ------ | ------------------------------- | ---------------------------- |
| GET    | `/v1/admin/settings`            | List all settings            |
| PUT    | `/v1/admin/settings/:key`       | Update a setting             |
| DELETE | `/v1/admin/settings/:key`       | Delete a setting             |
| GET    | `/v1/admin/x402`                | Get x402 payment config      |
| PUT    | `/v1/admin/x402`                | Update x402 payment config   |
| GET    | `/v1/admin/users`               | List all users (super-admin) |
| DELETE | `/v1/admin/users/:user_id`      | Delete user (cascade; platform admin only) |
| GET    | `/v1/admin/chains`              | List chains (admin view)     |
| POST   | `/v1/admin/chains`              | Create chain                 |
| PUT    | `/v1/admin/chains/:chain_id`    | Update chain                 |
| DELETE | `/v1/admin/chains/:chain_id`    | Delete chain                 |
| GET    | `/v1/admin/orgs/:org_id/limits` | Get org limits               |
| PUT    | `/v1/admin/orgs/:org_id/limits` | Update org limits            |
| PUT    | `/v1/admin/orgs/:org_id/billing-tier` | Set org billing tier (free/pro/business) |

---

## Notes

- The API expects `email` and `password` for `/v1/auth/token` (not `username`).
- Secret paths are wildcard routes — e.g. `api-keys/openai`, `config/prod/db`.
- **POST /v1/auth/refresh** exists but returns **400** with "Refresh tokens not yet implemented". Use token issuance (e.g. `POST /v1/auth/token` or `POST /v1/auth/agent-token`) instead.
- Request processing order (rate limit, auth, billing, handler) and how to interpret 401, 402, 403, 429: see [Request pipeline](/docs/reference/request-pipeline).
- Crypto proxy routes additionally require the `crypto_proxy_enabled` claim in the JWT.
- See [Authentication](/docs/human-api/authentication) for details on obtaining JWTs.


---

## Changelog

---
title: Changelog
description: Product and API changelog for 1claw.
sidebar_position: 3
---

# Changelog

For detailed release history, see the [1clawAI GitHub](https://github.com/1clawAI) repositories.

## API stability

The **/v1** API is stable. Breaking changes would be accompanied by a new version prefix or clear deprecation notices. New optional fields or endpoints are added in a backward-compatible way.

## 2026-02 (latest)

### Tenderly Transaction Simulation

- **New:** `POST /v1/agents/:agent_id/transactions/simulate` — pre-flight simulation of EVM transactions via Tenderly. Returns balance changes, gas estimates, decoded errors, and a Tenderly dashboard deep-link. No signing or broadcasting occurs.
- **New:** `POST /v1/agents/:agent_id/transactions/simulate-bundle` — simulate multiple sequential transactions (e.g. approve + swap).
- **New:** `simulate_first` flag on `POST /v1/agents/:agent_id/transactions` — runs a Tenderly simulation before signing. If the simulation reverts, returns HTTP 422 and does not sign. Org admins can enforce this as mandatory via the `crypto_proxy.require_simulation` setting.
- **New:** EIP-1559 (Type 2) transaction signing — set `max_fee_per_gas` and `max_priority_fee_per_gas` instead of legacy `gas_price`.
- **New:** Automatic nonce resolution via `eth_getTransactionCount` RPC when `nonce` is omitted.
- **New:** Address derivation from private key (secp256k1) — the simulation endpoint resolves the `from` address without exposing the key.
- **New:** `simulate_transaction` MCP tool and `simulate_first` argument on the `submit_transaction` MCP tool (defaults to `true`).
- **New:** `simulateTransaction()` and `simulateBundle()` methods in the TypeScript SDK.
- **New:** Dashboard Transaction Builder on the agent detail page — simulate, review balance changes, then confirm and send.
- **New:** Transaction history table on the agent detail page with simulation status badges and tx hash copy.

### Transaction replay protection & response hardening

- **New:** `Idempotency-Key` header on `POST /v1/agents/:agent_id/transactions` — duplicate requests with the same key within 24 hours return the cached response (200) instead of signing and broadcasting again. In-progress duplicates return 409 Conflict.
- **New:** Server-side nonce serialization — when `nonce` is omitted, the server atomically reserves the next nonce per agent+chain+address via `SELECT FOR UPDATE` locking, preventing nonce collisions between concurrent requests.
- **New:** `signed_tx` redacted by default — GET transaction endpoints omit the raw signed transaction hex. Pass `?include_signed_tx=true` to include it. The initial POST submission always returns it.
- **New:** `transaction_idempotency` and `nonce_tracker` database tables (migrations 034, 035).
- **New:** Nightly cleanup of expired idempotency keys (>48h) in the existing credit expiry background job.
- **Updated:** SDK `submitTransaction()` auto-generates an `Idempotency-Key` header (UUID). Callers can override via `options.idempotencyKey`.
- **Updated:** MCP `submit_transaction` tool auto-generates an `Idempotency-Key` header.
- **Updated:** OpenAPI spec documents `Idempotency-Key` header and `include_signed_tx` query parameter.

### Admin user management

- **New:** `DELETE /v1/admin/users/:user_id` — platform admins can delete users. Cascades: delete share links created by the user, clear `agents.created_by`, then delete the user (device_auth_codes and user_api_keys CASCADE in DB). Cannot delete self or the last owner of the platform org.
- **New:** `scripts/cleanup-test-users.sh` — removes test users by display name. Auth via `ONECLAW_TOKEN` or `ADMIN_EMAIL` + `ADMIN_PASSWORD`. Use `--dry-run` to list only.

### Security audit hardening

- **New:** Per-agent transaction guardrails — `tx_allowed_chains`, `tx_to_allowlist`, `tx_max_value_eth`, `tx_daily_limit_eth` enforced before signing.
- **New:** Audit hash chain — each event stores `prev_event_id` and SHA-256 `integrity_hash` for tamper detection.
- **New:** x402 payment replay protection — payment proofs deduplicated via SHA-256 before facilitator verification.
- **New:** Authorization enforcement on `delete_secret`, `list_secrets`, and `list_versions` (policy check, not just org membership).
- **Improved:** CORS defaults to `https://1claw.xyz` in production (no more permissive `Any` fallback).
- **Improved:** CSP removes `unsafe-inline` and `unsafe-eval` from `script-src`.
- **Improved:** Global rate limiting middleware applied to all API routes.
- **Improved:** Dependency overrides for `minimatch`, `ajv`, `hono` to address known CVEs.

### Dashboard UX — CopyableId

- **New:** One-click copy for every UUID, path, and identifier across the dashboard. Vault IDs, agent IDs, principal IDs, audit actor/resource IDs, API key prefixes, secret paths, and user/org IDs in the sidebar — all clickable with tooltip confirmation.

### Quota exemption for platform admin orgs

- **New:** `CallerIdentity.quota_exempt` flag resolved at authentication time. Platform admin org (and its agents) bypasses all billing checks. Cleaner than per-route overrides — single source of truth in auth middleware.

### Policy UI improvements

- **New:** Vault selector dropdown on Create Access Policy page — pick any vault, not just the one in the URL.
- **New:** Agent principal picker — select from existing agents or type a custom agent ID.
- **New:** Edit policy dialog — update permissions, conditions (JSON), and expiry on existing policies.
- **New:** Delete policy from the policies list page.

### Agent integration guide

- **New:** Agent detail page in the dashboard now includes a tabbed integration guide with copy-paste code snippets for TypeScript SDK, Python, curl, and MCP configuration.

### PolyForm Noncommercial License

- All repositories now include the [PolyForm Noncommercial License 1.0.0](https://polyformproject.org/licenses/noncommercial/1.0.0).

### Organization migration

- All repositories moved to the [1clawAI](https://github.com/1clawAI) GitHub organization.

### Email notifications

- **New:** Transactional emails via [Resend](https://resend.com) for account and security events.
- Welcome email on signup (email/password and Google OAuth).
- Share invite email when a secret is shared by email.
- Share access notification to the creator when a shared secret is accessed.
- Password change confirmation email.
- API key creation notification email.
- Emails are fire-and-forget (non-blocking) and silently skipped when no `RESEND_API_KEY` is configured.

### Sharing & invite-by-email

- **New:** `external_email` share type — share secrets with users who don't have accounts yet.
- **New:** Claim-on-login — pending email shares are automatically claimed when the recipient signs up or logs in.
- **New:** Share access notifications — creators are emailed each time a shared secret is accessed.
- **New:** `POST /v1/auth/signup` — self-service account registration via email/password.

### SDK rewrite (`@1claw/sdk` v0.2.0)

- **New:** Full API parity — typed methods for all 42+ REST API endpoints.
- Resource modules: `vault`, `secrets`, `access`, `agents`, `sharing`, `auth`, `apiKeys`, `billing`, `audit`, `org`.
- `createClient()` factory with auto-authentication (API key or agent credentials).
- `{ data, error, meta }` response envelope on every method.
- Typed error hierarchy: `AuthError`, `PaymentRequiredError`, `NotFoundError`, `RateLimitError`, etc.
- x402 auto-payment support with configurable `maxAutoPayUsd`.
- MCP tool layer: `McpHandler` and `getMcpToolDefinitions()` for AI agent frameworks.
- `auth.signup()` for programmatic account creation.
- `sharing.create()` with email support for invite-by-email.

### Examples repository

- **New:** `examples/basic/` — TypeScript scripts for vault CRUD, secrets, billing, signup, and email sharing.
- **New:** `examples/nextjs-agent-secret/` — Next.js 14 app with Claude AI agent accessing vault secrets.

### MCP server (`@1claw/mcp`)

- **New:** MCP server for AI agent access to secrets via the Model Context Protocol.
- 7 tools: `list_secrets`, `get_secret`, `put_secret`, `delete_secret`, `describe_secret`, `rotate_and_store`, `get_env_bundle`.
- Browsable `vault://secrets` resource.
- **Dual transport:** Local stdio mode (Claude Desktop, Cursor) and hosted HTTP streaming mode (`mcp.1claw.xyz`).
- Per-session authentication in hosted mode — each connection gets its own vault client.
- Auto-deploy to Cloud Run via GitHub Actions.

### Billing & usage tracking

- **New:** Usage tracking middleware records every authenticated API request.
- **New:** Free tier — 1,000 requests/month per organization.
- **New:** x402 Payment Required responses when free tier is exhausted, with on-chain payment on Base (EIP-155:8453).
- **New:** Billing API — `GET /v1/billing/usage` (summary) and `GET /v1/billing/history` (event log).
- Unified billing across dashboard, SDK, and MCP — all count against the same quota.

### Vault API

- Added `POST /v1/agents/:agent_id/rotate-key` endpoint for agent key rotation.
- Added `GET /v1/billing/usage` and `GET /v1/billing/history` endpoints.
- Usage middleware tracks method, endpoint, principal, status code, and price per request.
- x402 middleware enforces free tier limits and returns payment-required responses.

### Infrastructure

- Cloud Run deployment for MCP server (`oneclaw-mcp`).
- Terraform resources for MCP service and domain mapping.
- GitHub Actions workflow for MCP auto-deploy.
- CI pipeline expanded: MCP type check, build, Docker image build and Trivy scan.

### Documentation

- **New:** Full MCP documentation section (overview, setup, tool reference, security, deployment).
- **New:** Billing & usage guide.
- **New:** Deploying updates guide.
- Updated intro, MCP integration guide, and changelog.
- Updated `llms.txt` and `llms-full.txt` with MCP and billing content.

### Initial release (2026-02 early)

- Vault API: vaults, secrets (CRUD + versioning), policies, agents, sharing, audit log, org management.
- Human auth: email/password, Google OAuth, personal API keys (`1ck_`).
- Agent auth: agent API keys (`ocv_`) exchanged for short-lived JWTs.
- Envelope encryption with Cloud KMS (or SoftHSM for local dev).
- Dashboard: Next.js with full secret management UI.
- TypeScript SDK (`@1claw/sdk`).
- Docusaurus docs site.
- Terraform infrastructure (Supabase, GCP, Vercel).


---

## Error codes

---
title: Error codes
description: HTTP status codes and RFC 7807 problem-details returned by the 1claw API; 400, 401, 403, 404, 409, 410, 429, 500.
sidebar_position: 1
---

# Error codes

All errors return a JSON body with **RFC 7807** fields: `type`, `title`, `status`, `detail`. The API does not expose stack traces or internal details in 500 responses.

## HTTP status codes

| Code | Title | When |
|------|--------|------|
| 400 | Bad Request | Invalid path format, invalid request body, validation failure (e.g. empty permissions). |
| 401 | Unauthorized | Missing `Authorization` header, invalid Bearer format, invalid or expired JWT, wrong credentials (email/password or API key). |
| 403 | Forbidden | Valid JWT but no permission for this resource (policy does not grant the action, or not vault owner). |
| 403 | Resource Limit Exceeded | Tier limit reached for vaults, secrets, or agents. `type` field is `"resource_limit_exceeded"`. Upgrade plan or delete unused resources. |
| 404 | Not Found | Vault, secret, policy, or agent not found (wrong ID or path). |
| 409 | Conflict | Request conflicts with current state (e.g. name already exists, if applicable). |
| 410 | Gone | Secret has expired, been soft-deleted, or exceeded max_access_count. |
| 429 | Too Many Requests | Rate limit exceeded. |
| 500 | Internal Server Error | Server-side failure (e.g. database, KMS). Detail is generic. |

## Example body

```json
{
  "type": "about:blank",
  "title": "Forbidden",
  "status": 403,
  "detail": "Insufficient permissions"
}
```

Use `status` for programmatic handling; use `detail` for user-facing messages (it may vary by endpoint).

## Resource limit errors

When creating vaults, secrets, or agents beyond your tier's quota, the API returns `403` with `type: "resource_limit_exceeded"` instead of `"about:blank"`:

```json
{
  "type": "resource_limit_exceeded",
  "title": "Resource Limit Exceeded",
  "status": 403,
  "detail": "Vault limit reached (3/3 on free tier). Upgrade your plan for more."
}
```

Check the `type` field to distinguish permission errors from quota errors. The `detail` includes the current count, limit, and tier name.


---

## Glossary

---
title: Glossary
description: Definitions of terms used in 1claw — vaults, secrets, policies, agents, and billing.
sidebar_position: 4
---

# Glossary

Terms you’ll see in the API, dashboard, SDK, and CLI.

**Agent** — A registered identity (e.g. a bot or MCP server) that authenticates with an agent API key (`ocv_...`). Agents get a short-lived JWT and call the same REST API as humans, but access is limited by policies. See [Register an agent](/docs/human-api/agents/register-agent) and [Agent API overview](/docs/agent-api/overview).

**API key (personal)** — A `1ck_` key that represents a user. Used as a Bearer token for all API endpoints. Created in the dashboard under API Keys or via the API. Used for CLI, CI/CD, or scripting. See [Authentication](/docs/human-api/authentication).

**API key (agent)** — A one-time `ocv_` key returned when you register an agent. The agent exchanges it for a JWT via `POST /v1/auth/agent-token`. Store it securely; it cannot be retrieved again. Rotate via the dashboard or `POST /v1/agents/:id/rotate-key`.

**DEK (Data Encryption Key)** — A random key generated per secret (or per write). Used with AES-256-GCM to encrypt the secret value. The DEK is then wrapped by the vault’s KEK and stored with the ciphertext. See [Key hierarchy](/docs/security/key-hierarchy).

**Envelope encryption** — The pattern 1claw uses: encrypt the secret with a DEK, then encrypt (wrap) the DEK with a KEK that lives in the HSM. The database only stores ciphertext and the wrapped DEK, so a DB compromise does not expose secrets without HSM access.

**Grant** — See **Policy**. In the API and docs, “grant” and “policy” are used interchangeably for the rule that grants a principal access to secret paths.

**HSM (Hardware Security Module)** — A secure vault for keys. In 1claw, production uses Google Cloud KMS; keys never leave the HSM. Used for KEKs and JWT signing. See [HSM architecture](/docs/concepts/hsm-architecture).

**KEK (Key Encryption Key)** — One per vault, stored in the HSM. Used only to wrap and unwrap DEKs when storing or reading secrets. See [Key hierarchy](/docs/security/key-hierarchy).

**JWT (JSON Web Token)** — The short-lived token returned after login or agent-token exchange. Sent as `Authorization: Bearer <token>`. Contains claims such as user/agent id, org id, and (for agents) scopes.

**MCP (Model Context Protocol)** — A protocol that lets AI tools (e.g. Claude, Cursor) call 1claw tools (list secrets, get secret, etc.) over stdio or HTTP. The 1claw MCP server is available at mcp.1claw.xyz or as a local process. See [MCP Server](/docs/mcp/overview).

**Path** — A slash-separated identifier for a secret inside a vault (e.g. `api-keys/stripe`, `config/prod/db`). Used in policies as glob patterns (e.g. `**`, `prod/*`). See [Secrets model](/docs/concepts/secrets-model).

**Policy** — A rule that grants a **principal** (user or agent) permission to read and/or write secrets in a vault that match a **secret path pattern**. Policies can have conditions (IP, time window) and an expiry. Created and managed per vault. See [Create a policy](/docs/human-api/grants/create-grant) and [Scoped permissions](/docs/guides/scoped-permissions).

**Principal** — The identity that a policy applies to: a **user** (by user ID) or an **agent** (by agent ID). The principal must match the caller for the policy to apply.

**Resource limit** — A cap on how many vaults, secrets, or agents your organization can have, based on your subscription tier. When you hit the limit, the API returns 403 with `type: "resource_limit_exceeded"`. Upgrade your plan or delete unused resources. See [Billing & Usage](/docs/guides/billing-and-usage).

**Scope** — For agents, the set of path patterns the agent is allowed to access. When the agent has no explicit scopes on its record, scopes are derived from its policies (the policies’ `secret_path_pattern` values). If there are no policies, the default is `["*"]`. Scopes are embedded in the agent’s JWT.

**Secret** — A named value (e.g. API key, password) stored in a vault at a **path**. Has a type, optional metadata, optional expiry, and versioning. Values are encrypted at rest; list responses never include values. See [Secrets model](/docs/concepts/secrets-model).

**Share** — A time-limited, optionally passphrase- and IP-restricted link or grant that lets someone (user, agent, or anyone with the link) access a secret. Created via `POST /v1/secrets/:id/share`. See [Sharing secrets](/docs/guides/sharing-secrets).

**Vault** — A named container for secrets (e.g. "Production", "CI"). Each vault has its own KEK in the HSM. You create vaults, then store secrets at paths inside them. Access is controlled by policies on the vault. See [What is 1claw?](/docs/concepts/what-is-1claw).

**x402** — A protocol for per-request payment. When your tier’s request quota is exceeded and you’ve chosen x402 as your overage method, the API can return 402 Payment Required with payment details; after payment, you retry the request. See [Billing & Usage](/docs/guides/billing-and-usage).

**Crypto proxy** — A feature that lets agents sign and broadcast on-chain transactions without ever reading the private key. When enabled for an agent, the agent is blocked from reading `private_key` and `ssh_key` secrets; it must use the transaction endpoints. See [Crypto Transaction Proxy](/docs/guides/crypto-proxy).


---

## Rate limits

---
title: Rate limits
description: Rate limiting may be applied per org or per token; 429 responses indicate limit exceeded; exact limits depend on deployment.
sidebar_position: 2
---

# Rate limits

<!-- TODO: verify --> The vault API may enforce rate limits per organization or per token. When a limit is exceeded, the server returns **429 Too Many Requests** with a problem-details body.

Exact limits (requests per minute or per hour) depend on your deployment (e.g. Cloud Run and any API gateway in front). Check your infrastructure config or contact the operator. Common practice is to use exponential backoff and retry when you receive 429.


---

## Request pipeline

---
title: Request pipeline
description: How each API request is processed — authentication, rate limiting, billing, and audit. Helps you understand when you might see 401, 402, or 429.
sidebar_position: 1
---

# Request pipeline

Every request to the Vault API passes through a fixed pipeline. Understanding the order helps you interpret errors (e.g. 401 before 402, or rate limit before handler).

## Order of processing

For **authenticated** routes (vaults, secrets, agents, billing, etc.), the pipeline is:

1. **Audit** — The request is recorded for the audit log (path, method, principal). Failures here are rare and internal.
2. **Rate limit** — Global rate limiting applies. If exceeded, the API returns **429 Too Many Requests** with a `Retry-After` header when available.
3. **Auth** — The `Authorization` header is validated (JWT or API key). Missing or invalid auth → **401 Unauthorized**. This happens before any billing or quota logic.
4. **IP filter** — If your organization has IP allow/block rules, they are applied here. Denied → **403 Forbidden**.
5. **x402** — If the endpoint is subject to payment (e.g. overage when quota is exceeded and x402 is your overage method), the API may return **402 Payment Required** with payment details. Otherwise the request continues.
6. **Usage** — The request is counted for billing and quota (monthly request limit, prepaid credits, or x402).
7. **Quota headers** — Response headers such as `X-RateLimit-Requests-Used` and `X-Credit-Balance-Cents` are set for the client.
8. **Handler** — Your request is executed (e.g. get vault, list secrets). Here you may see **403 Forbidden** (e.g. policy denied, resource limit exceeded) or **404** / **410** for missing or expired resources.

So for example: if your token is invalid, you get **401** before any 402 or rate-limit check. If your token is valid but you’ve hit a resource limit (vaults, agents, secrets), you get **403** with `type: "resource_limit_exceeded"` from the handler, not from middleware.

## Special routes

- **Public routes** (e.g. `POST /v1/auth/token`, `GET /v1/health`) — No auth layer; rate limit and audit still apply.
- **Share access** (`GET /v1/share/:share_id`) — Unauthenticated; only x402 (and rate limit at the outer layer) apply. Passphrase and IP allowlist are enforced inside the handler.
- **Crypto proxy routes** (e.g. `POST /v1/agents/:id/transactions`) — Same as authenticated, plus a check that the JWT has `crypto_proxy_enabled`. Without it → **403**.
- **Webhook** (`POST /v1/billing/webhooks`) — No auth middleware; Stripe signature verification is done in the handler.

## What you can rely on

- **401** always means auth failed (missing, invalid, or expired token or API key). Fix by re-authenticating or rotating the key.
- **402** means payment or quota is required for this request (tier limit exceeded; pay via x402 or use prepaid credits). See [Billing & Usage](/docs/guides/billing-and-usage).
- **403** can mean: no permission for this resource (policy), resource limit exceeded (subscription tier), IP denied, or (on crypto proxy routes) agent not allowed to sign. The response body `type` and `detail` distinguish these.
- **429** means you hit the global rate limit. Back off and retry; optional `Retry-After` header indicates when to retry.

See [Error codes](/docs/reference/error-codes) for the full list of status codes and problem details.


---

## curl examples

---
title: curl examples
description: Example curl commands for 1claw auth, vaults, secrets, and agents; works with any environment that has curl.
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# curl examples

Base URL used: `https://api.1claw.xyz`. Replace with your Cloud Run URL if different.

## Human: get JWT

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s -X POST https://api.1claw.xyz/v1/auth/token \
  -H "Content-Type: application/json" \
  -d '{"email":"you@example.com","password":"your-password"}'
# Save access_token as $TOKEN
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
import { createClient } from "@1claw/sdk";
const client = createClient({ baseUrl: "https://api.1claw.xyz" });
await client.auth.login({ email: "you@example.com", password: "your-password" });
```

</TabItem>
</Tabs>

## Human: create vault and secret

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
export TOKEN="<access_token>"

# Create vault
curl -s -X POST https://api.1claw.xyz/v1/vaults \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"My Vault","description":"Secrets"}'

# Store secret (use vault id from response)
export VAULT_ID="<vault_id>"
curl -s -X PUT "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"api_key","value":"sk-proj-..."}'

# Read secret
curl -s "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const client = createClient({
  baseUrl: "https://api.1claw.xyz",
  apiKey: process.env.ONECLAW_API_KEY,
});

const { data: vault } = await client.vault.create({
  name: "My Vault",
  description: "Secrets",
});

await client.secrets.set(vault.id, "api-keys/openai", "sk-proj-...", {
  type: "api_key",
});

const { data: secret } = await client.secrets.get(vault.id, "api-keys/openai");
console.log(secret.value);
```

</TabItem>
</Tabs>

## Agent: get JWT and read secret

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s -X POST https://api.1claw.xyz/v1/auth/agent-token \
  -H "Content-Type: application/json" \
  -d '{"agent_id":"<uuid>","api_key":"ocv_..."}'
# Save access_token

export TOKEN="<agent_access_token>"
export VAULT_ID="<vault_id>"
curl -s "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const agentClient = createClient({
  baseUrl: "https://api.1claw.xyz",
  agentId: "<uuid>",
  apiKey: "ocv_...",
});

const { data: secret } = await agentClient.secrets.get(VAULT_ID, "api-keys/openai");
```

</TabItem>
</Tabs>

## List secrets (metadata only)

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets" \
  -H "Authorization: Bearer $TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
const { data } = await client.secrets.list(VAULT_ID);
```

</TabItem>
</Tabs>

## Create policy (grant agent read)

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
curl -s -X POST "https://api.1claw.xyz/v1/vaults/$VAULT_ID/policies" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "secret_path_pattern": "**",
    "principal_type": "agent",
    "principal_id": "<agent_uuid>",
    "permissions": ["read"]
  }'
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
await client.access.grantAgent({
  vault_id: VAULT_ID,
  secret_path_pattern: "**",
  principal_id: "<agent_uuid>",
  permissions: ["read"],
});
```

</TabItem>
</Tabs>


---

## JavaScript / TypeScript SDK

---
title: JavaScript / TypeScript SDK
description: "@1claw/sdk provides full API parity — vaults, secrets, sharing, agents, billing, auth, and MCP tool integration."
sidebar_position: 1
---

# JavaScript / TypeScript SDK

The official TypeScript SDK provides full API parity with the 1Claw REST API. It supports both human and agent workflows, x402 auto-payment, and an MCP tool layer for AI agents.

**Repository:** [github.com/1clawAI/1claw-sdk](https://github.com/1clawAI/1claw-sdk)

**API contract:** The SDK is built against the **OpenAPI 3.1** spec. Request/response types are generated from it. The spec is published as [@1claw/openapi-spec](https://www.npmjs.com/package/@1claw/openapi-spec) (npm) for codegen or custom clients. See [API reference](/docs/reference/api-reference) for the endpoint list.

## Install

```bash
npm install @1claw/sdk
```

## Quick start

```ts
import { createClient } from "@1claw/sdk";

const client = createClient({
    baseUrl: "https://api.1claw.xyz",
    apiKey: process.env.ONECLAW_API_KEY, // personal API key (1ck_...)
});

// Create a vault
const { data: vault } = await client.vault.create({
    name: "my-vault",
    description: "Production secrets",
});

// Store a secret
await client.secrets.set(vault.id, "STRIPE_KEY", "sk_live_...", {
    type: "api_key",
});

// Retrieve a secret
const { data: secret } = await client.secrets.get(vault.id, "STRIPE_KEY");
console.log(secret.value); // use securely, don't log in production
```

## Authentication

The SDK supports three authentication methods:

```ts
// 1. Personal API key (recommended for server-side)
const client = createClient({
    baseUrl: "https://api.1claw.xyz",
    apiKey: "1ck_...",
});

// 2. Agent credentials
const client = createClient({
    baseUrl: "https://api.1claw.xyz",
    agentId: "uuid",
    apiKey: "ocv_...",
});

// 3. Manual auth (signup, email/password)
const client = createClient({ baseUrl: "https://api.1claw.xyz" });
await client.auth.signup({
    email: "me@example.com",
    password: "...",
    display_name: "Me",
});
// or
await client.auth.login({ email: "me@example.com", password: "..." });
```

## Resource modules

All API endpoints are organized into resource modules:

| Module             | Methods                                                                                            |
| ------------------ | -------------------------------------------------------------------------------------------------- |
| `client.auth`      | `login()`, `signup()`, `agentToken()`, `apiKeyToken()`, `google()`, `changePassword()`, `logout()` |
| `client.vault`     | `create()`, `list()`, `get()`, `delete()`                                                          |
| `client.secrets`   | `set()`, `get()`, `list()`, `delete()`, `rotate()`                                                 |
| `client.access`    | `grantHuman()`, `grantAgent()`, `update()`, `revoke()`, `listGrants()`                             |
| `client.agents`    | `create()`, `list()`, `get()`, `update()`, `delete()`, `rotateKey()`                               |
| `client.sharing`   | `create()`, `access()`, `revoke()`                                                                 |
| `client.approvals` | `request()`, `list()`, `approve()`, `deny()`, `check()`                                            |
| `client.apiKeys`   | `create()`, `list()`, `revoke()`                                                                   |
| `client.billing`   | `usage()`, `history()`                                                                             |
| `client.audit`     | `query()`                                                                                          |
| `client.org`       | `listMembers()`, `updateMemberRole()`, `removeMember()`                                            |
| `client.x402`      | `getPaymentRequirement()`, `pay()`, `verifyReceipt()`, `withPayment()`                             |

## Sharing by email

Share a secret with someone who may not have an account yet:

```ts
const { data: share } = await client.sharing.create(secretId, {
    recipient_type: "external_email",
    email: "colleague@example.com",
    expires_at: "2026-04-01T00:00:00Z",
    max_access_count: 3,
});
// Recipient gets an email; the share auto-claims when they sign up/log in
```

## Response envelope

Every method returns `{ data, error, meta }`:

```ts
const res = await client.secrets.get(vaultId, "MY_KEY");
if (res.error) {
    console.error(res.error.message); // typed error
} else {
    console.log(res.data.value);
}
```

## Error types

```ts
import {
    OneclawError,
    AuthError, // 401
    PaymentRequiredError, // 402 (x402)
    ApprovalRequiredError, // 403 (approval pending)
    NotFoundError, // 404
    RateLimitError, // 429
} from "@1claw/sdk";
```

## MCP tool integration

The SDK includes an MCP tool layer for AI agent frameworks:

```ts
import { McpHandler, getMcpToolDefinitions } from "@1claw/sdk/mcp";

// Get tool schemas for registration with an AI framework
const tools = getMcpToolDefinitions();

// Handle tool calls
const handler = new McpHandler(client);
const result = await handler.handle("1claw_get_secret", {
    vault_id: "...",
    key: "STRIPE_KEY",
});
```

Available MCP tools: `1claw_get_secret`, `1claw_set_secret`, `1claw_list_secret_keys`, `1claw_request_approval`, `1claw_check_approval_status`, `1claw_pay_and_fetch`, `1claw_create_vault`, `1claw_list_vaults`, `1claw_share_secret`.

## Examples

See the [examples repository](https://github.com/1clawAI/1claw-examples) for runnable demos:

- **basic/** — Vault CRUD, secrets, billing, signup, email-based sharing
- **nextjs-agent-secret/** — AI agent with Claude accessing vault secrets via MCP tools

## OpenAPI types

The SDK’s TypeScript types are generated from the [OpenAPI 3.1 spec](https://www.npmjs.com/package/@1claw/openapi-spec). You can import raw generated types:

```ts
import type { paths, components, operations, ApiSchemas } from "@1claw/sdk";

type Vault = ApiSchemas["VaultResponse"];
type Agent = ApiSchemas["AgentResponse"];
```

To regenerate types after spec changes (when working from the monorepo): `npm run generate` in the SDK package.

## Human API (dashboard / server)

The dashboard uses **fetch** and **TanStack Query** with the same base URL and JWT. There is no separate "human" SDK package; use `@1claw/sdk` or fetch with the [Human API](/docs/human-api/overview) docs.


---

## SDKs overview

---
title: SDKs overview
description: 1claw provides a TypeScript/JavaScript SDK (@1claw/sdk); curl and fetch examples work with any language.
sidebar_position: 0
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# SDKs overview

- **JavaScript/TypeScript** — Official `@1claw/sdk`. Built from the same OpenAPI 3.1 spec as the API; supports agent auth, secrets, billing, and optional x402. See [JavaScript SDK](/docs/sdks/javascript).
- **Python** — No official SDK yet; use [curl examples](/docs/sdks/curl-examples) or implement a thin client with `requests`/`httpx`. See [Python](/docs/sdks/python).
- **curl / HTTP** — All endpoints are REST; you can use curl, fetch, or any HTTP client. See [curl examples](/docs/sdks/curl-examples).

**API contract:** The canonical source of truth for the API is the **OpenAPI 3.1** spec. It is published as the npm package [@1claw/openapi-spec](https://www.npmjs.com/package/@1claw/openapi-spec) (YAML and JSON) and is used to generate the SDK's types and to validate requests. For a concise endpoint list, see [API reference](/docs/reference/api-reference).

## Quick example

<Tabs groupId="code-examples">
<TabItem value="curl" label="curl">

```bash
# Fetch a secret
curl -s "https://api.1claw.xyz/v1/vaults/$VAULT_ID/secrets/api-keys/openai" \
  -H "Authorization: Bearer $TOKEN"
```

</TabItem>
<TabItem value="typescript" label="TypeScript">

```typescript
import { createClient } from "@1claw/sdk";

const client = createClient({
  baseUrl: "https://api.1claw.xyz",
  apiKey: process.env.ONECLAW_API_KEY,
});

const { data: secret } = await client.secrets.get(VAULT_ID, "api-keys/openai");
console.log(secret.value);
```

</TabItem>
</Tabs>


---

## Python

---
title: Python
description: Use requests or httpx with the 1claw REST API from Python; no official SDK yet; examples show agent auth and fetching a secret.
sidebar_position: 2
---

# Python

There is no official Python SDK. Use **requests** or **httpx** with the same REST endpoints. Below: agent auth and fetch secret.

## Agent: get token and fetch secret

```python
import os
import requests

BASE = "https://api.1claw.xyz"
AGENT_ID = os.environ["ONECLAW_AGENT_ID"]
API_KEY = os.environ["ONECLAW_AGENT_API_KEY"]

# Get JWT
r = requests.post(
    f"{BASE}/v1/auth/agent-token",
    json={"agent_id": AGENT_ID, "api_key": API_KEY},
)
r.raise_for_status()
token = r.json()["access_token"]
headers = {"Authorization": f"Bearer {token}"}

# List secrets (metadata only)
vault_id = "ae370174-9aee-4b02-ba7c-d1519930c709"
r = requests.get(f"{BASE}/v1/vaults/{vault_id}/secrets", headers=headers)
r.raise_for_status()
for s in r.json()["secrets"]:
    print(s["path"], s["type"])

# Get secret value
r = requests.get(
    f"{BASE}/v1/vaults/{vault_id}/secrets/api-keys/openai",
    headers=headers,
)
r.raise_for_status()
value = r.json()["value"]
# Use value only as needed; don't log or persist
```

## Human: email/password token

```python
r = requests.post(
    f"{BASE}/v1/auth/token",
    json={"email": "you@example.com", "password": "your-password"},
)
r.raise_for_status()
token = r.json()["access_token"]
```

Then use `Authorization: Bearer <token>` for vaults, secrets, policies, and agents as in the [Human API](/docs/human-api/overview) docs.


---

## Agent keys

---
title: Agent keys
description: Every agent gets three types of keys at creation — API key, Ed25519 signing key, and P-256 ECDH key. Learn how they're created, stored, and accessed.
sidebar_position: 2
---

# Agent keys

When you [register an agent](/docs/human-api/agents/register-agent) via `POST /v1/agents`, 1Claw automatically generates three types of cryptographic material:

| Key | Algorithm | Purpose | Storage |
|-----|-----------|---------|---------|
| **API key** | `ocv_...` (random, argon2-hashed) | Authentication — token exchange via `POST /v1/auth/agent-token` | Hash in DB; plaintext returned once at creation |
| **Signing key** | Ed25519 | Message signing, identity verification | Private key in `__agent-keys` vault; public key on agent record (`ssh_public_key`) |
| **ECDH key** | P-256 (secp256r1) | Key agreement — derive shared secrets for encrypted agent-to-agent messaging | Private key in `__agent-keys` vault; public key on agent record (`ecdh_public_key`) |

## How keys are created

All three keys are generated server-side during `POST /v1/agents`:

1. **API key** — 32 random bytes, base64url-encoded with `ocv_` prefix. The plaintext is returned in the response and never stored; only the argon2 hash is persisted.

2. **Ed25519 signing keypair** — Generated via `ed25519-dalek`. The 32-byte private key (base64) is stored as an encrypted secret in the org's `__agent-keys` vault at `agents/{agent_id}/ssh/private_key`. The 32-byte public key (base64) is stored on the agent record.

3. **P-256 ECDH keypair** — Generated via the `p256` crate. The 32-byte private scalar (base64) is stored in `__agent-keys` at `agents/{agent_id}/ecdh/private_key`. The 65-byte uncompressed SEC1 public point (base64) is stored on the agent record.

The `__agent-keys` vault is auto-created per organization on first agent creation. All secrets in it are HSM-encrypted with the same envelope encryption used for regular vaults.

## Accessing keys via the API

### Public keys (no special access needed)

Public keys are returned on the agent record:

```bash
# Human (list/get agents)
curl -H "Authorization: Bearer <token>" \
  https://api.1claw.xyz/v1/agents/<agent_id>

# Agent (get own profile)
curl -H "Authorization: Bearer <agent-jwt>" \
  https://api.1claw.xyz/v1/agents/me
```

Response includes:

```json
{
  "id": "ec7e0226-...",
  "name": "Alice",
  "ssh_public_key": "m+Z6jV5W86WMTV27cpk9QGXIo+fP1OX88dHxdj6DHUI=",
  "ecdh_public_key": "BDq8k3Lw...base64...65bytes..."
}
```

### Private keys (requires access policy)

Private keys are stored as secrets in the `__agent-keys` vault. To let an agent read its own keys, grant it a policy:

```bash
# Grant agent read access to its own keys in __agent-keys
curl -X POST "https://api.1claw.xyz/v1/vaults/<agent-keys-vault-id>/policies" \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: application/json" \
  -d '{
    "principal_type": "agent",
    "principal_id": "<agent_id>",
    "permissions": ["read"],
    "secret_path_pattern": "agents/<agent_id>/**"
  }'
```

Then the agent can read its private keys:

```bash
# Ed25519 signing key
GET /v1/vaults/<agent-keys-vault-id>/secrets/agents/<agent_id>/ssh/private_key

# P-256 ECDH key
GET /v1/vaults/<agent-keys-vault-id>/secrets/agents/<agent_id>/ecdh/private_key
```

:::tip
The `ecdh:setup-agents` script in the [Google A2A example](/docs/guides/give-agent-access) automates this: it creates agents and grants each one read access to its own keys.
:::

## Key formats

| Key | Format | Size |
|-----|--------|------|
| Ed25519 private | Raw 32-byte seed, base64 | 44 chars |
| Ed25519 public | Raw 32-byte verifying key, base64 | 44 chars |
| P-256 ECDH private | Raw 32-byte scalar, base64 | 44 chars |
| P-256 ECDH public | Uncompressed SEC1 point (`04 \|\| x \|\| y`), base64 | 88 chars |

## Design rationale

- **Ed25519 for signing** — Deterministic nonces (no catastrophic nonce-reuse bugs), fast, compact signatures. Widely used in SSH, TLS, and JWT.
- **P-256 ECDH for key agreement** — Standard curve for Diffie-Hellman key exchange (TLS, ECIES, A2A messaging). Distinct from the signing key because signing and key agreement are separate cryptographic operations.
- **Separate keys for separate purposes** — Signing keys prove identity; ECDH keys establish shared secrets. Using the same key for both is a known anti-pattern that can leak information about the private key.


---

## Compliance

---
title: Compliance
description: 1claw supports compliance efforts through HSM-backed encryption, access control, audit logging, and revocation; use the audit log and policies to demonstrate control.
sidebar_position: 3
---

# Compliance

1claw supports common compliance requirements by design:

- **Encryption at rest** — All secrets are encrypted with HSM-backed keys (envelope encryption). Keys never leave the HSM. This supports requirements for strong encryption and key management.

- **Access control** — Access is granted only via explicit policies. No default read; every request is authorized. Supports least-privilege and access review.

- **Audit trail** — All access (and failures) can be recorded. Secret values are never logged. You can export or forward events to your SIEM or compliance tooling. Supports accountability and incident response.

- **Revocation** — Policies can be deleted and agents deactivated immediately. Supports “revoke access when needed” and offboarding.

- **No long-term secret storage in clients** — Agents fetch secrets at runtime and do not need to store them. Reduces exposure in agent environments.

Use the [Audit API](/docs/guides/audit-and-compliance) and policy model to document who had access to what and when. For specific standards (e.g. SOC 2, HIPAA), work with your compliance team to map controls to 1claw’s capabilities and your deployment (e.g. GCP and Supabase compliance offerings).


---

## HSM overview

---
title: HSM overview
description: 1claw uses an HSM to hold KEKs and the JWT signing key; in production this is Google Cloud KMS; secrets are encrypted with keys that never leave the HSM.
sidebar_position: 0
---

# HSM overview

1claw encrypts secrets with keys that never leave a **Hardware Security Module (HSM)**. In production the HSM is **Google Cloud KMS**: a key ring holds the JWT signing key (Ed25519) and one Key Encryption Key (KEK) per vault (symmetric). The vault API runs on Cloud Run and has IAM permissions to use KMS for sign, encrypt, and decrypt; it never has access to raw key material.

## What the HSM protects

- **KEKs** — Used only to wrap and unwrap Data Encryption Keys (DEKs). Each vault has one KEK. DEKs encrypt secret values; KEKs encrypt DEKs. Without KMS access, ciphertext and wrapped DEKs in the database are useless.
- **JWT signing key** — Ed25519 key used to sign and verify access tokens. Signing is done inside KMS; only the public key is used for verification. This prevents token forgery.

## Operational security

- Key material does not exist in application memory except as wrapped ciphertext or short-lived DEK during decrypt.
- Access to KMS is via IAM; the vault service account has least-privilege roles (cryptoKeyEncrypterDecrypter for KEKs, signerVerifier for JWT).
- Audit logging records access and failures without logging secret values.

See [Key hierarchy](/docs/security/key-hierarchy) and [HSM architecture](/docs/concepts/hsm-architecture) for the encryption flow.


---

## Key hierarchy

---
title: Key hierarchy
description: KEK per vault in HSM; DEK per secret (or operation); DEK wraps plaintext, KEK wraps DEK; JWT key is separate Ed25519 in same key ring.
sidebar_position: 1
---

# Key hierarchy

1. **JWT signing key (Ed25519)** — One per deployment. Lives in the same KMS key ring. Used only to sign and verify JWTs. Public key is used by the API to validate tokens; private key never leaves KMS.

2. **KEK (Key Encryption Key)** — One per vault. Symmetric key in KMS. Created when the vault is created. Used only to:
   - **Wrap** a DEK (encrypt the DEK) when storing a secret.
   - **Unwrap** a DEK (decrypt the DEK) when reading a secret.

3. **DEK (Data Encryption Key)** — Random 256-bit key generated per secret (or per write). Used with AES-256-GCM to encrypt the secret value. The DEK is then wrapped by the vault’s KEK and stored with the ciphertext. It exists in plain form only inside the API during the encrypt/decrypt operation and is never persisted in the clear.

## Flow summary

- **Write:** Generate DEK → Encrypt plaintext with DEK (AES-GCM) → Wrap DEK with KEK (KMS) → Store ciphertext + wrapped DEK + IV + tag.
- **Read:** Load ciphertext + wrapped DEK → Unwrap DEK with KEK (KMS) → Decrypt ciphertext with DEK → Return plaintext.

This is standard **envelope encryption**. Compromise of the database or application does not reveal secrets without KMS access.


---

## Two-factor authentication (2FA)

---
title: Two-factor authentication
description: "TOTP-based two-factor authentication protects human logins with an authenticator app and recovery codes."
sidebar_position: 5
---

# Two-factor authentication (2FA)

1Claw supports TOTP-based two-factor authentication for human user accounts. When enabled, logging in requires both your password (or Google OAuth) **and** a 6-digit code from an authenticator app such as Google Authenticator, Authy, or 1Password.

2FA is optional but recommended. It can be enabled and disabled from **Settings → Security** in the dashboard.

## How it works

### Setup

1. Navigate to **Settings → Security** in the dashboard.
2. Click **Enable 2FA**.
3. Scan the QR code with your authenticator app, or enter the secret key manually.
4. Enter the 6-digit code from your app to verify.
5. Save your **8 recovery codes** in a safe place. Each code can only be used once.

### Login with 2FA

1. Enter your email/password or sign in with Google as usual.
2. If 2FA is enabled, the server responds with a short-lived MFA challenge token instead of a session JWT.
3. The dashboard prompts you for a 6-digit code from your authenticator app.
4. Enter the code (or a recovery code) to complete sign-in.

### Disabling 2FA

1. Navigate to **Settings → Security**.
2. Click **Disable 2FA**.
3. Confirm by entering your current TOTP code or your account password.

## Technical details

| Property       | Value                                  |
| -------------- | -------------------------------------- |
| Algorithm      | TOTP (RFC 6238), SHA-1                 |
| Digits         | 6                                      |
| Step           | 30 seconds                             |
| Skew           | ±1 step (clock drift tolerance)        |
| Secret storage | AES-256-GCM encrypted at rest          |
| Recovery codes | 8 codes, encrypted at rest, single-use |
| MFA token TTL  | 5 minutes                              |

### API endpoints

| Endpoint                         | Auth                  | Description                                                |
| -------------------------------- | --------------------- | ---------------------------------------------------------- |
| `GET /v1/auth/mfa/status`        | Bearer JWT            | Returns whether MFA is enabled                             |
| `POST /v1/auth/mfa/setup`        | Bearer JWT            | Generates TOTP secret and returns QR code URI              |
| `POST /v1/auth/mfa/verify-setup` | Bearer JWT            | Verifies initial code, enables MFA, returns recovery codes |
| `POST /v1/auth/mfa/verify`       | None (uses MFA token) | Validates TOTP code during login, returns session JWT      |
| `DELETE /v1/auth/mfa`            | Bearer JWT            | Disables MFA (requires TOTP code or password)              |

### MFA challenge flow

When a user with 2FA enabled authenticates via `POST /v1/auth/token` or `POST /v1/auth/google`, the server returns:

```json
{
    "mfa_required": true,
    "mfa_token": "<short-lived-jwt>",
    "access_token": "",
    "token_type": "Bearer",
    "expires_in": 300
}
```

The client then calls `POST /v1/auth/mfa/verify` with the `mfa_token` and the user's TOTP code to receive the real session JWT.

### Encryption

TOTP secrets and recovery codes are encrypted with AES-256-GCM using a server-side key configured via the `ONECLAW_TOTP_ENCRYPTION_KEY` environment variable (64 hex characters = 32 bytes). In development mode, if the variable is not set, a key is derived automatically.

## Scope

2FA applies only to **human user logins** (email/password and Google OAuth). It does not apply to:

- Agent authentication (agents use API keys, not passwords)
- Personal API key authentication (`1ck_` keys)
- MCP server connections (token-based)


---

## Zero trust

---
title: Zero trust
description: "1claw enforces zero-trust style guarantees: secrets at rest encrypted, access only after auth and policy check, revocation immediate, all access audited."
sidebar_position: 2
---

# Zero trust

1claw is designed with zero-trust principles: no implicit trust of the network or the database; every access is authenticated and authorized, and secrets are protected at rest and in use.

## Secrets at rest

- Every secret is encrypted with a DEK; the DEK is wrapped by a KEK that never leaves the HSM. The database stores only ciphertext and wrapped DEKs. There is no “master key” in the app; decryption requires a successful KMS unwrap.

## No implicit access

- Every request must present a valid JWT. There is no “open” read. Policies explicitly grant read/write to principals for path patterns. Vault owners have full access to their vault; everyone else needs a policy. Agents have no access until a human creates a policy.

## Revocation is immediate

- Deleting a policy removes access on the next request. Deactivating an agent prevents new tokens; existing short-lived JWTs expire. Rotating an agent key invalidates the old key. There is no long-lived cache of secrets in the API.

## Audit

- Access (and relevant failures) are logged. Secret values are never written to the audit log. You can use the log for compliance and incident response.

## In transit

- Clients must use HTTPS. The API is served over TLS. Do not send tokens or secrets over plain HTTP.

See [Trust model](/docs/concepts/trust-model) for a short summary.
